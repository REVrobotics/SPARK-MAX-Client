/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

var SPARK$MAX$Types_pb = require('./SPARK-MAX-Types_pb.js');
goog.object.extend(proto, SPARK$MAX$Types_pb);
goog.exportSymbol('proto.sparkmax.DRVStat0', null, global);
goog.exportSymbol('proto.sparkmax.DRVStat1', null, global);
goog.exportSymbol('proto.sparkmax.DRVStatusRequest', null, global);
goog.exportSymbol('proto.sparkmax.DRVStatusResponse', null, global);
goog.exportSymbol('proto.sparkmax.FaultFlags', null, global);
goog.exportSymbol('proto.sparkmax.burnRequest', null, global);
goog.exportSymbol('proto.sparkmax.burnResponse', null, global);
goog.exportSymbol('proto.sparkmax.clearFaultsRequest', null, global);
goog.exportSymbol('proto.sparkmax.clearFaultsResponse', null, global);
goog.exportSymbol('proto.sparkmax.connectRequest', null, global);
goog.exportSymbol('proto.sparkmax.connectResponse', null, global);
goog.exportSymbol('proto.sparkmax.disconnectRequest', null, global);
goog.exportSymbol('proto.sparkmax.disconnectResponse', null, global);
goog.exportSymbol('proto.sparkmax.extendedListResponse', null, global);
goog.exportSymbol('proto.sparkmax.factoryResetRequest', null, global);
goog.exportSymbol('proto.sparkmax.firmwareRequest', null, global);
goog.exportSymbol('proto.sparkmax.firmwareResponse', null, global);
goog.exportSymbol('proto.sparkmax.followerRequest', null, global);
goog.exportSymbol('proto.sparkmax.getParameterRequest', null, global);
goog.exportSymbol('proto.sparkmax.idAssignmentRequest', null, global);
goog.exportSymbol('proto.sparkmax.identifyRequest', null, global);
goog.exportSymbol('proto.sparkmax.listRequest', null, global);
goog.exportSymbol('proto.sparkmax.listResponse', null, global);
goog.exportSymbol('proto.sparkmax.parameterListRequest', null, global);
goog.exportSymbol('proto.sparkmax.parameterListResponse', null, global);
goog.exportSymbol('proto.sparkmax.parameterResponse', null, global);
goog.exportSymbol('proto.sparkmax.pingRequest', null, global);
goog.exportSymbol('proto.sparkmax.pingResponse', null, global);
goog.exportSymbol('proto.sparkmax.rootCommand', null, global);
goog.exportSymbol('proto.sparkmax.rootResponse', null, global);
goog.exportSymbol('proto.sparkmax.setParameterRequest', null, global);
goog.exportSymbol('proto.sparkmax.setpointRequest', null, global);
goog.exportSymbol('proto.sparkmax.setpointResponse', null, global);
goog.exportSymbol('proto.sparkmax.telemetryData', null, global);
goog.exportSymbol('proto.sparkmax.telemetryId', null, global);
goog.exportSymbol('proto.sparkmax.telemetryRequest', null, global);
goog.exportSymbol('proto.sparkmax.telemetryResponse', null, global);

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.connectRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.connectRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.connectRequest.displayName = 'proto.sparkmax.connectRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.connectRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.connectRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.connectRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.connectRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    device: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.connectRequest}
 */
proto.sparkmax.connectRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.connectRequest;
  return proto.sparkmax.connectRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.connectRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.connectRequest}
 */
proto.sparkmax.connectRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setDevice(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.connectRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.connectRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.connectRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.connectRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getDevice();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string device = 1;
 * @return {string}
 */
proto.sparkmax.connectRequest.prototype.getDevice = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.sparkmax.connectRequest.prototype.setDevice = function(value) {
  jspb.Message.setProto3StringField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.connectResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.connectResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.connectResponse.displayName = 'proto.sparkmax.connectResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.connectResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.connectResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.connectResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.connectResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    connected: jspb.Message.getFieldWithDefault(msg, 1, false),
    root: (f = msg.getRoot()) && proto.sparkmax.rootResponse.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.connectResponse}
 */
proto.sparkmax.connectResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.connectResponse;
  return proto.sparkmax.connectResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.connectResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.connectResponse}
 */
proto.sparkmax.connectResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setConnected(value);
      break;
    case 2:
      var value = new proto.sparkmax.rootResponse;
      reader.readMessage(value,proto.sparkmax.rootResponse.deserializeBinaryFromReader);
      msg.setRoot(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.connectResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.connectResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.connectResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.connectResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getConnected();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
  f = message.getRoot();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.sparkmax.rootResponse.serializeBinaryToWriter
    );
  }
};


/**
 * optional bool connected = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.connectResponse.prototype.getConnected = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.sparkmax.connectResponse.prototype.setConnected = function(value) {
  jspb.Message.setProto3BooleanField(this, 1, value);
};


/**
 * optional rootResponse root = 2;
 * @return {?proto.sparkmax.rootResponse}
 */
proto.sparkmax.connectResponse.prototype.getRoot = function() {
  return /** @type{?proto.sparkmax.rootResponse} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.rootResponse, 2));
};


/** @param {?proto.sparkmax.rootResponse|undefined} value */
proto.sparkmax.connectResponse.prototype.setRoot = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.sparkmax.connectResponse.prototype.clearRoot = function() {
  this.setRoot(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.connectResponse.prototype.hasRoot = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.disconnectRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.disconnectRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.disconnectRequest.displayName = 'proto.sparkmax.disconnectRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.disconnectRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.disconnectRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.disconnectRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.disconnectRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    device: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.disconnectRequest}
 */
proto.sparkmax.disconnectRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.disconnectRequest;
  return proto.sparkmax.disconnectRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.disconnectRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.disconnectRequest}
 */
proto.sparkmax.disconnectRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setDevice(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.disconnectRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.disconnectRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.disconnectRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.disconnectRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getDevice();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string device = 1;
 * @return {string}
 */
proto.sparkmax.disconnectRequest.prototype.getDevice = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.sparkmax.disconnectRequest.prototype.setDevice = function(value) {
  jspb.Message.setProto3StringField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.disconnectResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.disconnectResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.disconnectResponse.displayName = 'proto.sparkmax.disconnectResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.disconnectResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.disconnectResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.disconnectResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.disconnectResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    connected: jspb.Message.getFieldWithDefault(msg, 1, false),
    root: (f = msg.getRoot()) && proto.sparkmax.rootResponse.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.disconnectResponse}
 */
proto.sparkmax.disconnectResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.disconnectResponse;
  return proto.sparkmax.disconnectResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.disconnectResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.disconnectResponse}
 */
proto.sparkmax.disconnectResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setConnected(value);
      break;
    case 2:
      var value = new proto.sparkmax.rootResponse;
      reader.readMessage(value,proto.sparkmax.rootResponse.deserializeBinaryFromReader);
      msg.setRoot(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.disconnectResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.disconnectResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.disconnectResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.disconnectResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getConnected();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
  f = message.getRoot();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.sparkmax.rootResponse.serializeBinaryToWriter
    );
  }
};


/**
 * optional bool connected = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.disconnectResponse.prototype.getConnected = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.sparkmax.disconnectResponse.prototype.setConnected = function(value) {
  jspb.Message.setProto3BooleanField(this, 1, value);
};


/**
 * optional rootResponse root = 2;
 * @return {?proto.sparkmax.rootResponse}
 */
proto.sparkmax.disconnectResponse.prototype.getRoot = function() {
  return /** @type{?proto.sparkmax.rootResponse} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.rootResponse, 2));
};


/** @param {?proto.sparkmax.rootResponse|undefined} value */
proto.sparkmax.disconnectResponse.prototype.setRoot = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.sparkmax.disconnectResponse.prototype.clearRoot = function() {
  this.setRoot(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.disconnectResponse.prototype.hasRoot = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.pingRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.pingRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.pingRequest.displayName = 'proto.sparkmax.pingRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.pingRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.pingRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.pingRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.pingRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    device: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.pingRequest}
 */
proto.sparkmax.pingRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.pingRequest;
  return proto.sparkmax.pingRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.pingRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.pingRequest}
 */
proto.sparkmax.pingRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setDevice(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.pingRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.pingRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.pingRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.pingRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getDevice();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string device = 1;
 * @return {string}
 */
proto.sparkmax.pingRequest.prototype.getDevice = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.sparkmax.pingRequest.prototype.setDevice = function(value) {
  jspb.Message.setProto3StringField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.pingResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.pingResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.pingResponse.displayName = 'proto.sparkmax.pingResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.pingResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.pingResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.pingResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.pingResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    root: (f = msg.getRoot()) && proto.sparkmax.rootResponse.toObject(includeInstance, f),
    connected: jspb.Message.getFieldWithDefault(msg, 2, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.pingResponse}
 */
proto.sparkmax.pingResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.pingResponse;
  return proto.sparkmax.pingResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.pingResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.pingResponse}
 */
proto.sparkmax.pingResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.sparkmax.rootResponse;
      reader.readMessage(value,proto.sparkmax.rootResponse.deserializeBinaryFromReader);
      msg.setRoot(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setConnected(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.pingResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.pingResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.pingResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.pingResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRoot();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.sparkmax.rootResponse.serializeBinaryToWriter
    );
  }
  f = message.getConnected();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
};


/**
 * optional rootResponse root = 1;
 * @return {?proto.sparkmax.rootResponse}
 */
proto.sparkmax.pingResponse.prototype.getRoot = function() {
  return /** @type{?proto.sparkmax.rootResponse} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.rootResponse, 1));
};


/** @param {?proto.sparkmax.rootResponse|undefined} value */
proto.sparkmax.pingResponse.prototype.setRoot = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.sparkmax.pingResponse.prototype.clearRoot = function() {
  this.setRoot(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.pingResponse.prototype.hasRoot = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bool connected = 2;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.pingResponse.prototype.getConnected = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 2, false));
};


/** @param {boolean} value */
proto.sparkmax.pingResponse.prototype.setConnected = function(value) {
  jspb.Message.setProto3BooleanField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.burnRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.burnRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.burnRequest.displayName = 'proto.sparkmax.burnRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.burnRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.burnRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.burnRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.burnRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    root: (f = msg.getRoot()) && proto.sparkmax.rootCommand.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.burnRequest}
 */
proto.sparkmax.burnRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.burnRequest;
  return proto.sparkmax.burnRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.burnRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.burnRequest}
 */
proto.sparkmax.burnRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.sparkmax.rootCommand;
      reader.readMessage(value,proto.sparkmax.rootCommand.deserializeBinaryFromReader);
      msg.setRoot(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.burnRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.burnRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.burnRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.burnRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRoot();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.sparkmax.rootCommand.serializeBinaryToWriter
    );
  }
};


/**
 * optional rootCommand root = 1;
 * @return {?proto.sparkmax.rootCommand}
 */
proto.sparkmax.burnRequest.prototype.getRoot = function() {
  return /** @type{?proto.sparkmax.rootCommand} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.rootCommand, 1));
};


/** @param {?proto.sparkmax.rootCommand|undefined} value */
proto.sparkmax.burnRequest.prototype.setRoot = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.sparkmax.burnRequest.prototype.clearRoot = function() {
  this.setRoot(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.burnRequest.prototype.hasRoot = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.burnResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.burnResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.burnResponse.displayName = 'proto.sparkmax.burnResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.burnResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.burnResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.burnResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.burnResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    root: (f = msg.getRoot()) && proto.sparkmax.rootResponse.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.burnResponse}
 */
proto.sparkmax.burnResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.burnResponse;
  return proto.sparkmax.burnResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.burnResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.burnResponse}
 */
proto.sparkmax.burnResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.sparkmax.rootResponse;
      reader.readMessage(value,proto.sparkmax.rootResponse.deserializeBinaryFromReader);
      msg.setRoot(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.burnResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.burnResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.burnResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.burnResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRoot();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.sparkmax.rootResponse.serializeBinaryToWriter
    );
  }
};


/**
 * optional rootResponse root = 1;
 * @return {?proto.sparkmax.rootResponse}
 */
proto.sparkmax.burnResponse.prototype.getRoot = function() {
  return /** @type{?proto.sparkmax.rootResponse} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.rootResponse, 1));
};


/** @param {?proto.sparkmax.rootResponse|undefined} value */
proto.sparkmax.burnResponse.prototype.setRoot = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.sparkmax.burnResponse.prototype.clearRoot = function() {
  this.setRoot(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.burnResponse.prototype.hasRoot = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.rootCommand = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.rootCommand, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.rootCommand.displayName = 'proto.sparkmax.rootCommand';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.rootCommand.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.rootCommand.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.rootCommand} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.rootCommand.toObject = function(includeInstance, msg) {
  var f, obj = {
    device: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.rootCommand}
 */
proto.sparkmax.rootCommand.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.rootCommand;
  return proto.sparkmax.rootCommand.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.rootCommand} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.rootCommand}
 */
proto.sparkmax.rootCommand.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setDevice(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.rootCommand.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.rootCommand.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.rootCommand} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.rootCommand.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getDevice();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string device = 1;
 * @return {string}
 */
proto.sparkmax.rootCommand.prototype.getDevice = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.sparkmax.rootCommand.prototype.setDevice = function(value) {
  jspb.Message.setProto3StringField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.rootResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.rootResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.rootResponse.displayName = 'proto.sparkmax.rootResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.rootResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.rootResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.rootResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.rootResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    error: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.rootResponse}
 */
proto.sparkmax.rootResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.rootResponse;
  return proto.sparkmax.rootResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.rootResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.rootResponse}
 */
proto.sparkmax.rootResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setError(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.rootResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.rootResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.rootResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.rootResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getError();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional string error = 2;
 * @return {string}
 */
proto.sparkmax.rootResponse.prototype.getError = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.sparkmax.rootResponse.prototype.setError = function(value) {
  jspb.Message.setProto3StringField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.listRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.listRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.listRequest.displayName = 'proto.sparkmax.listRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.listRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.listRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.listRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.listRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    root: (f = msg.getRoot()) && proto.sparkmax.rootCommand.toObject(includeInstance, f),
    all: jspb.Message.getFieldWithDefault(msg, 2, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.listRequest}
 */
proto.sparkmax.listRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.listRequest;
  return proto.sparkmax.listRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.listRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.listRequest}
 */
proto.sparkmax.listRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.sparkmax.rootCommand;
      reader.readMessage(value,proto.sparkmax.rootCommand.deserializeBinaryFromReader);
      msg.setRoot(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setAll(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.listRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.listRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.listRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.listRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRoot();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.sparkmax.rootCommand.serializeBinaryToWriter
    );
  }
  f = message.getAll();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
};


/**
 * optional rootCommand root = 1;
 * @return {?proto.sparkmax.rootCommand}
 */
proto.sparkmax.listRequest.prototype.getRoot = function() {
  return /** @type{?proto.sparkmax.rootCommand} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.rootCommand, 1));
};


/** @param {?proto.sparkmax.rootCommand|undefined} value */
proto.sparkmax.listRequest.prototype.setRoot = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.sparkmax.listRequest.prototype.clearRoot = function() {
  this.setRoot(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.listRequest.prototype.hasRoot = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bool all = 2;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.listRequest.prototype.getAll = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 2, false));
};


/** @param {boolean} value */
proto.sparkmax.listRequest.prototype.setAll = function(value) {
  jspb.Message.setProto3BooleanField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.extendedListResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.extendedListResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.extendedListResponse.displayName = 'proto.sparkmax.extendedListResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.extendedListResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.extendedListResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.extendedListResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.extendedListResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    interfacename: jspb.Message.getFieldWithDefault(msg, 1, ""),
    drivername: jspb.Message.getFieldWithDefault(msg, 2, ""),
    devicename: jspb.Message.getFieldWithDefault(msg, 3, ""),
    deviceid: jspb.Message.getFieldWithDefault(msg, 4, 0),
    updateable: jspb.Message.getFieldWithDefault(msg, 5, false),
    uniqueid: jspb.Message.getFieldWithDefault(msg, 6, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.extendedListResponse}
 */
proto.sparkmax.extendedListResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.extendedListResponse;
  return proto.sparkmax.extendedListResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.extendedListResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.extendedListResponse}
 */
proto.sparkmax.extendedListResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setInterfacename(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setDrivername(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setDevicename(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setDeviceid(value);
      break;
    case 5:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setUpdateable(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setUniqueid(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.extendedListResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.extendedListResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.extendedListResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.extendedListResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getInterfacename();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getDrivername();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getDevicename();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getDeviceid();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = message.getUpdateable();
  if (f) {
    writer.writeBool(
      5,
      f
    );
  }
  f = message.getUniqueid();
  if (f !== 0) {
    writer.writeUint32(
      6,
      f
    );
  }
};


/**
 * optional string interfaceName = 1;
 * @return {string}
 */
proto.sparkmax.extendedListResponse.prototype.getInterfacename = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.sparkmax.extendedListResponse.prototype.setInterfacename = function(value) {
  jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string driverName = 2;
 * @return {string}
 */
proto.sparkmax.extendedListResponse.prototype.getDrivername = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.sparkmax.extendedListResponse.prototype.setDrivername = function(value) {
  jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional string deviceName = 3;
 * @return {string}
 */
proto.sparkmax.extendedListResponse.prototype.getDevicename = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/** @param {string} value */
proto.sparkmax.extendedListResponse.prototype.setDevicename = function(value) {
  jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional uint32 deviceId = 4;
 * @return {number}
 */
proto.sparkmax.extendedListResponse.prototype.getDeviceid = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.sparkmax.extendedListResponse.prototype.setDeviceid = function(value) {
  jspb.Message.setProto3IntField(this, 4, value);
};


/**
 * optional bool updateable = 5;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.extendedListResponse.prototype.getUpdateable = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 5, false));
};


/** @param {boolean} value */
proto.sparkmax.extendedListResponse.prototype.setUpdateable = function(value) {
  jspb.Message.setProto3BooleanField(this, 5, value);
};


/**
 * optional uint32 uniqueId = 6;
 * @return {number}
 */
proto.sparkmax.extendedListResponse.prototype.getUniqueid = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.sparkmax.extendedListResponse.prototype.setUniqueid = function(value) {
  jspb.Message.setProto3IntField(this, 6, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.listResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.sparkmax.listResponse.repeatedFields_, null);
};
goog.inherits(proto.sparkmax.listResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.listResponse.displayName = 'proto.sparkmax.listResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.sparkmax.listResponse.repeatedFields_ = [1,2,4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.listResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.listResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.listResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.listResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    devicelistList: jspb.Message.getRepeatedField(msg, 1),
    driverlistList: jspb.Message.getRepeatedField(msg, 2),
    root: (f = msg.getRoot()) && proto.sparkmax.rootResponse.toObject(includeInstance, f),
    extendedlistList: jspb.Message.toObjectList(msg.getExtendedlistList(),
    proto.sparkmax.extendedListResponse.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.listResponse}
 */
proto.sparkmax.listResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.listResponse;
  return proto.sparkmax.listResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.listResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.listResponse}
 */
proto.sparkmax.listResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.addDevicelist(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.addDriverlist(value);
      break;
    case 3:
      var value = new proto.sparkmax.rootResponse;
      reader.readMessage(value,proto.sparkmax.rootResponse.deserializeBinaryFromReader);
      msg.setRoot(value);
      break;
    case 4:
      var value = new proto.sparkmax.extendedListResponse;
      reader.readMessage(value,proto.sparkmax.extendedListResponse.deserializeBinaryFromReader);
      msg.addExtendedlist(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.listResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.listResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.listResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.listResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getDevicelistList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      1,
      f
    );
  }
  f = message.getDriverlistList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      2,
      f
    );
  }
  f = message.getRoot();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.sparkmax.rootResponse.serializeBinaryToWriter
    );
  }
  f = message.getExtendedlistList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.sparkmax.extendedListResponse.serializeBinaryToWriter
    );
  }
};


/**
 * repeated string deviceList = 1;
 * @return {!Array<string>}
 */
proto.sparkmax.listResponse.prototype.getDevicelistList = function() {
  return /** @type {!Array<string>} */ (jspb.Message.getRepeatedField(this, 1));
};


/** @param {!Array<string>} value */
proto.sparkmax.listResponse.prototype.setDevicelistList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {string} value
 * @param {number=} opt_index
 */
proto.sparkmax.listResponse.prototype.addDevicelist = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


proto.sparkmax.listResponse.prototype.clearDevicelistList = function() {
  this.setDevicelistList([]);
};


/**
 * repeated string driverList = 2;
 * @return {!Array<string>}
 */
proto.sparkmax.listResponse.prototype.getDriverlistList = function() {
  return /** @type {!Array<string>} */ (jspb.Message.getRepeatedField(this, 2));
};


/** @param {!Array<string>} value */
proto.sparkmax.listResponse.prototype.setDriverlistList = function(value) {
  jspb.Message.setField(this, 2, value || []);
};


/**
 * @param {string} value
 * @param {number=} opt_index
 */
proto.sparkmax.listResponse.prototype.addDriverlist = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 2, value, opt_index);
};


proto.sparkmax.listResponse.prototype.clearDriverlistList = function() {
  this.setDriverlistList([]);
};


/**
 * optional rootResponse root = 3;
 * @return {?proto.sparkmax.rootResponse}
 */
proto.sparkmax.listResponse.prototype.getRoot = function() {
  return /** @type{?proto.sparkmax.rootResponse} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.rootResponse, 3));
};


/** @param {?proto.sparkmax.rootResponse|undefined} value */
proto.sparkmax.listResponse.prototype.setRoot = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.sparkmax.listResponse.prototype.clearRoot = function() {
  this.setRoot(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.listResponse.prototype.hasRoot = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * repeated extendedListResponse extendedList = 4;
 * @return {!Array<!proto.sparkmax.extendedListResponse>}
 */
proto.sparkmax.listResponse.prototype.getExtendedlistList = function() {
  return /** @type{!Array<!proto.sparkmax.extendedListResponse>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.sparkmax.extendedListResponse, 4));
};


/** @param {!Array<!proto.sparkmax.extendedListResponse>} value */
proto.sparkmax.listResponse.prototype.setExtendedlistList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.sparkmax.extendedListResponse=} opt_value
 * @param {number=} opt_index
 * @return {!proto.sparkmax.extendedListResponse}
 */
proto.sparkmax.listResponse.prototype.addExtendedlist = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.sparkmax.extendedListResponse, opt_index);
};


proto.sparkmax.listResponse.prototype.clearExtendedlistList = function() {
  this.setExtendedlistList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.firmwareRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.sparkmax.firmwareRequest.repeatedFields_, null);
};
goog.inherits(proto.sparkmax.firmwareRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.firmwareRequest.displayName = 'proto.sparkmax.firmwareRequest';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.sparkmax.firmwareRequest.repeatedFields_ = [3];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.firmwareRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.firmwareRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.firmwareRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.firmwareRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    root: (f = msg.getRoot()) && proto.sparkmax.rootCommand.toObject(includeInstance, f),
    filename: jspb.Message.getFieldWithDefault(msg, 2, ""),
    devicestoupdateList: jspb.Message.getRepeatedField(msg, 3)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.firmwareRequest}
 */
proto.sparkmax.firmwareRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.firmwareRequest;
  return proto.sparkmax.firmwareRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.firmwareRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.firmwareRequest}
 */
proto.sparkmax.firmwareRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.sparkmax.rootCommand;
      reader.readMessage(value,proto.sparkmax.rootCommand.deserializeBinaryFromReader);
      msg.setRoot(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setFilename(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.addDevicestoupdate(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.firmwareRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.firmwareRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.firmwareRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.firmwareRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRoot();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.sparkmax.rootCommand.serializeBinaryToWriter
    );
  }
  f = message.getFilename();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getDevicestoupdateList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      3,
      f
    );
  }
};


/**
 * optional rootCommand root = 1;
 * @return {?proto.sparkmax.rootCommand}
 */
proto.sparkmax.firmwareRequest.prototype.getRoot = function() {
  return /** @type{?proto.sparkmax.rootCommand} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.rootCommand, 1));
};


/** @param {?proto.sparkmax.rootCommand|undefined} value */
proto.sparkmax.firmwareRequest.prototype.setRoot = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.sparkmax.firmwareRequest.prototype.clearRoot = function() {
  this.setRoot(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.firmwareRequest.prototype.hasRoot = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string filename = 2;
 * @return {string}
 */
proto.sparkmax.firmwareRequest.prototype.getFilename = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.sparkmax.firmwareRequest.prototype.setFilename = function(value) {
  jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * repeated string devicesToUpdate = 3;
 * @return {!Array<string>}
 */
proto.sparkmax.firmwareRequest.prototype.getDevicestoupdateList = function() {
  return /** @type {!Array<string>} */ (jspb.Message.getRepeatedField(this, 3));
};


/** @param {!Array<string>} value */
proto.sparkmax.firmwareRequest.prototype.setDevicestoupdateList = function(value) {
  jspb.Message.setField(this, 3, value || []);
};


/**
 * @param {string} value
 * @param {number=} opt_index
 */
proto.sparkmax.firmwareRequest.prototype.addDevicestoupdate = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 3, value, opt_index);
};


proto.sparkmax.firmwareRequest.prototype.clearDevicestoupdateList = function() {
  this.setDevicestoupdateList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.firmwareResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.firmwareResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.firmwareResponse.displayName = 'proto.sparkmax.firmwareResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.firmwareResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.firmwareResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.firmwareResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.firmwareResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    version: jspb.Message.getFieldWithDefault(msg, 1, ""),
    updatestarted: jspb.Message.getFieldWithDefault(msg, 2, false),
    root: (f = msg.getRoot()) && proto.sparkmax.rootResponse.toObject(includeInstance, f),
    major: jspb.Message.getFieldWithDefault(msg, 4, 0),
    minor: jspb.Message.getFieldWithDefault(msg, 5, 0),
    build: jspb.Message.getFieldWithDefault(msg, 6, 0),
    isdebug: jspb.Message.getFieldWithDefault(msg, 7, false),
    hardwareversion: jspb.Message.getFieldWithDefault(msg, 8, ""),
    isupdating: jspb.Message.getFieldWithDefault(msg, 9, false),
    updatestagemessage: jspb.Message.getFieldWithDefault(msg, 10, ""),
    updatestagepercent: +jspb.Message.getFieldWithDefault(msg, 11, 0.0),
    updatecomplete: jspb.Message.getFieldWithDefault(msg, 12, false),
    updatecompletedsuccessfully: jspb.Message.getFieldWithDefault(msg, 13, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.firmwareResponse}
 */
proto.sparkmax.firmwareResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.firmwareResponse;
  return proto.sparkmax.firmwareResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.firmwareResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.firmwareResponse}
 */
proto.sparkmax.firmwareResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setVersion(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setUpdatestarted(value);
      break;
    case 3:
      var value = new proto.sparkmax.rootResponse;
      reader.readMessage(value,proto.sparkmax.rootResponse.deserializeBinaryFromReader);
      msg.setRoot(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setMajor(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setMinor(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setBuild(value);
      break;
    case 7:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsdebug(value);
      break;
    case 8:
      var value = /** @type {string} */ (reader.readString());
      msg.setHardwareversion(value);
      break;
    case 9:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsupdating(value);
      break;
    case 10:
      var value = /** @type {string} */ (reader.readString());
      msg.setUpdatestagemessage(value);
      break;
    case 11:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setUpdatestagepercent(value);
      break;
    case 12:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setUpdatecomplete(value);
      break;
    case 13:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setUpdatecompletedsuccessfully(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.firmwareResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.firmwareResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.firmwareResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.firmwareResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getVersion();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getUpdatestarted();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
  f = message.getRoot();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.sparkmax.rootResponse.serializeBinaryToWriter
    );
  }
  f = message.getMajor();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = message.getMinor();
  if (f !== 0) {
    writer.writeUint32(
      5,
      f
    );
  }
  f = message.getBuild();
  if (f !== 0) {
    writer.writeUint32(
      6,
      f
    );
  }
  f = message.getIsdebug();
  if (f) {
    writer.writeBool(
      7,
      f
    );
  }
  f = message.getHardwareversion();
  if (f.length > 0) {
    writer.writeString(
      8,
      f
    );
  }
  f = message.getIsupdating();
  if (f) {
    writer.writeBool(
      9,
      f
    );
  }
  f = message.getUpdatestagemessage();
  if (f.length > 0) {
    writer.writeString(
      10,
      f
    );
  }
  f = message.getUpdatestagepercent();
  if (f !== 0.0) {
    writer.writeFloat(
      11,
      f
    );
  }
  f = message.getUpdatecomplete();
  if (f) {
    writer.writeBool(
      12,
      f
    );
  }
  f = message.getUpdatecompletedsuccessfully();
  if (f) {
    writer.writeBool(
      13,
      f
    );
  }
};


/**
 * optional string version = 1;
 * @return {string}
 */
proto.sparkmax.firmwareResponse.prototype.getVersion = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.sparkmax.firmwareResponse.prototype.setVersion = function(value) {
  jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional bool updateStarted = 2;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.firmwareResponse.prototype.getUpdatestarted = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 2, false));
};


/** @param {boolean} value */
proto.sparkmax.firmwareResponse.prototype.setUpdatestarted = function(value) {
  jspb.Message.setProto3BooleanField(this, 2, value);
};


/**
 * optional rootResponse root = 3;
 * @return {?proto.sparkmax.rootResponse}
 */
proto.sparkmax.firmwareResponse.prototype.getRoot = function() {
  return /** @type{?proto.sparkmax.rootResponse} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.rootResponse, 3));
};


/** @param {?proto.sparkmax.rootResponse|undefined} value */
proto.sparkmax.firmwareResponse.prototype.setRoot = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.sparkmax.firmwareResponse.prototype.clearRoot = function() {
  this.setRoot(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.firmwareResponse.prototype.hasRoot = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional uint32 major = 4;
 * @return {number}
 */
proto.sparkmax.firmwareResponse.prototype.getMajor = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.sparkmax.firmwareResponse.prototype.setMajor = function(value) {
  jspb.Message.setProto3IntField(this, 4, value);
};


/**
 * optional uint32 minor = 5;
 * @return {number}
 */
proto.sparkmax.firmwareResponse.prototype.getMinor = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.sparkmax.firmwareResponse.prototype.setMinor = function(value) {
  jspb.Message.setProto3IntField(this, 5, value);
};


/**
 * optional uint32 build = 6;
 * @return {number}
 */
proto.sparkmax.firmwareResponse.prototype.getBuild = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.sparkmax.firmwareResponse.prototype.setBuild = function(value) {
  jspb.Message.setProto3IntField(this, 6, value);
};


/**
 * optional bool isDebug = 7;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.firmwareResponse.prototype.getIsdebug = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 7, false));
};


/** @param {boolean} value */
proto.sparkmax.firmwareResponse.prototype.setIsdebug = function(value) {
  jspb.Message.setProto3BooleanField(this, 7, value);
};


/**
 * optional string hardwareVersion = 8;
 * @return {string}
 */
proto.sparkmax.firmwareResponse.prototype.getHardwareversion = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 8, ""));
};


/** @param {string} value */
proto.sparkmax.firmwareResponse.prototype.setHardwareversion = function(value) {
  jspb.Message.setProto3StringField(this, 8, value);
};


/**
 * optional bool isUpdating = 9;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.firmwareResponse.prototype.getIsupdating = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 9, false));
};


/** @param {boolean} value */
proto.sparkmax.firmwareResponse.prototype.setIsupdating = function(value) {
  jspb.Message.setProto3BooleanField(this, 9, value);
};


/**
 * optional string updateStageMessage = 10;
 * @return {string}
 */
proto.sparkmax.firmwareResponse.prototype.getUpdatestagemessage = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 10, ""));
};


/** @param {string} value */
proto.sparkmax.firmwareResponse.prototype.setUpdatestagemessage = function(value) {
  jspb.Message.setProto3StringField(this, 10, value);
};


/**
 * optional float updateStagePercent = 11;
 * @return {number}
 */
proto.sparkmax.firmwareResponse.prototype.getUpdatestagepercent = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 11, 0.0));
};


/** @param {number} value */
proto.sparkmax.firmwareResponse.prototype.setUpdatestagepercent = function(value) {
  jspb.Message.setProto3FloatField(this, 11, value);
};


/**
 * optional bool updateComplete = 12;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.firmwareResponse.prototype.getUpdatecomplete = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 12, false));
};


/** @param {boolean} value */
proto.sparkmax.firmwareResponse.prototype.setUpdatecomplete = function(value) {
  jspb.Message.setProto3BooleanField(this, 12, value);
};


/**
 * optional bool updateCompletedSuccessfully = 13;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.firmwareResponse.prototype.getUpdatecompletedsuccessfully = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 13, false));
};


/** @param {boolean} value */
proto.sparkmax.firmwareResponse.prototype.setUpdatecompletedsuccessfully = function(value) {
  jspb.Message.setProto3BooleanField(this, 13, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.setParameterRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.setParameterRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.setParameterRequest.displayName = 'proto.sparkmax.setParameterRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.setParameterRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.setParameterRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.setParameterRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.setParameterRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    root: (f = msg.getRoot()) && proto.sparkmax.rootCommand.toObject(includeInstance, f),
    parameter: jspb.Message.getFieldWithDefault(msg, 2, 0),
    value: jspb.Message.getFieldWithDefault(msg, 3, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.setParameterRequest}
 */
proto.sparkmax.setParameterRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.setParameterRequest;
  return proto.sparkmax.setParameterRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.setParameterRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.setParameterRequest}
 */
proto.sparkmax.setParameterRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.sparkmax.rootCommand;
      reader.readMessage(value,proto.sparkmax.rootCommand.deserializeBinaryFromReader);
      msg.setRoot(value);
      break;
    case 2:
      var value = /** @type {!proto.sparkmax.configParam} */ (reader.readEnum());
      msg.setParameter(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.setParameterRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.setParameterRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.setParameterRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.setParameterRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRoot();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.sparkmax.rootCommand.serializeBinaryToWriter
    );
  }
  f = message.getParameter();
  if (f !== 0.0) {
    writer.writeEnum(
      2,
      f
    );
  }
  f = message.getValue();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
};


/**
 * optional rootCommand root = 1;
 * @return {?proto.sparkmax.rootCommand}
 */
proto.sparkmax.setParameterRequest.prototype.getRoot = function() {
  return /** @type{?proto.sparkmax.rootCommand} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.rootCommand, 1));
};


/** @param {?proto.sparkmax.rootCommand|undefined} value */
proto.sparkmax.setParameterRequest.prototype.setRoot = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.sparkmax.setParameterRequest.prototype.clearRoot = function() {
  this.setRoot(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.setParameterRequest.prototype.hasRoot = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional configParam parameter = 2;
 * @return {!proto.sparkmax.configParam}
 */
proto.sparkmax.setParameterRequest.prototype.getParameter = function() {
  return /** @type {!proto.sparkmax.configParam} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {!proto.sparkmax.configParam} value */
proto.sparkmax.setParameterRequest.prototype.setParameter = function(value) {
  jspb.Message.setProto3EnumField(this, 2, value);
};


/**
 * optional string value = 3;
 * @return {string}
 */
proto.sparkmax.setParameterRequest.prototype.getValue = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/** @param {string} value */
proto.sparkmax.setParameterRequest.prototype.setValue = function(value) {
  jspb.Message.setProto3StringField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.getParameterRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.getParameterRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.getParameterRequest.displayName = 'proto.sparkmax.getParameterRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.getParameterRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.getParameterRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.getParameterRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.getParameterRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    root: (f = msg.getRoot()) && proto.sparkmax.rootCommand.toObject(includeInstance, f),
    parameter: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.getParameterRequest}
 */
proto.sparkmax.getParameterRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.getParameterRequest;
  return proto.sparkmax.getParameterRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.getParameterRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.getParameterRequest}
 */
proto.sparkmax.getParameterRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.sparkmax.rootCommand;
      reader.readMessage(value,proto.sparkmax.rootCommand.deserializeBinaryFromReader);
      msg.setRoot(value);
      break;
    case 2:
      var value = /** @type {!proto.sparkmax.configParam} */ (reader.readEnum());
      msg.setParameter(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.getParameterRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.getParameterRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.getParameterRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.getParameterRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRoot();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.sparkmax.rootCommand.serializeBinaryToWriter
    );
  }
  f = message.getParameter();
  if (f !== 0.0) {
    writer.writeEnum(
      2,
      f
    );
  }
};


/**
 * optional rootCommand root = 1;
 * @return {?proto.sparkmax.rootCommand}
 */
proto.sparkmax.getParameterRequest.prototype.getRoot = function() {
  return /** @type{?proto.sparkmax.rootCommand} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.rootCommand, 1));
};


/** @param {?proto.sparkmax.rootCommand|undefined} value */
proto.sparkmax.getParameterRequest.prototype.setRoot = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.sparkmax.getParameterRequest.prototype.clearRoot = function() {
  this.setRoot(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.getParameterRequest.prototype.hasRoot = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional configParam parameter = 2;
 * @return {!proto.sparkmax.configParam}
 */
proto.sparkmax.getParameterRequest.prototype.getParameter = function() {
  return /** @type {!proto.sparkmax.configParam} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {!proto.sparkmax.configParam} value */
proto.sparkmax.getParameterRequest.prototype.setParameter = function(value) {
  jspb.Message.setProto3EnumField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.parameterResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.parameterResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.parameterResponse.displayName = 'proto.sparkmax.parameterResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.parameterResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.parameterResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.parameterResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.parameterResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: jspb.Message.getFieldWithDefault(msg, 1, ""),
    type: jspb.Message.getFieldWithDefault(msg, 2, 0),
    status: jspb.Message.getFieldWithDefault(msg, 3, 0),
    root: (f = msg.getRoot()) && proto.sparkmax.rootResponse.toObject(includeInstance, f),
    number: jspb.Message.getFieldWithDefault(msg, 5, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.parameterResponse}
 */
proto.sparkmax.parameterResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.parameterResponse;
  return proto.sparkmax.parameterResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.parameterResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.parameterResponse}
 */
proto.sparkmax.parameterResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setValue(value);
      break;
    case 2:
      var value = /** @type {!proto.sparkmax.paramType} */ (reader.readEnum());
      msg.setType(value);
      break;
    case 3:
      var value = /** @type {!proto.sparkmax.paramStatus} */ (reader.readEnum());
      msg.setStatus(value);
      break;
    case 4:
      var value = new proto.sparkmax.rootResponse;
      reader.readMessage(value,proto.sparkmax.rootResponse.deserializeBinaryFromReader);
      msg.setRoot(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setNumber(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.parameterResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.parameterResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.parameterResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.parameterResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValue();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getType();
  if (f !== 0.0) {
    writer.writeEnum(
      2,
      f
    );
  }
  f = message.getStatus();
  if (f !== 0.0) {
    writer.writeEnum(
      3,
      f
    );
  }
  f = message.getRoot();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.sparkmax.rootResponse.serializeBinaryToWriter
    );
  }
  f = message.getNumber();
  if (f !== 0) {
    writer.writeUint32(
      5,
      f
    );
  }
};


/**
 * optional string value = 1;
 * @return {string}
 */
proto.sparkmax.parameterResponse.prototype.getValue = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.sparkmax.parameterResponse.prototype.setValue = function(value) {
  jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional paramType type = 2;
 * @return {!proto.sparkmax.paramType}
 */
proto.sparkmax.parameterResponse.prototype.getType = function() {
  return /** @type {!proto.sparkmax.paramType} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {!proto.sparkmax.paramType} value */
proto.sparkmax.parameterResponse.prototype.setType = function(value) {
  jspb.Message.setProto3EnumField(this, 2, value);
};


/**
 * optional paramStatus status = 3;
 * @return {!proto.sparkmax.paramStatus}
 */
proto.sparkmax.parameterResponse.prototype.getStatus = function() {
  return /** @type {!proto.sparkmax.paramStatus} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {!proto.sparkmax.paramStatus} value */
proto.sparkmax.parameterResponse.prototype.setStatus = function(value) {
  jspb.Message.setProto3EnumField(this, 3, value);
};


/**
 * optional rootResponse root = 4;
 * @return {?proto.sparkmax.rootResponse}
 */
proto.sparkmax.parameterResponse.prototype.getRoot = function() {
  return /** @type{?proto.sparkmax.rootResponse} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.rootResponse, 4));
};


/** @param {?proto.sparkmax.rootResponse|undefined} value */
proto.sparkmax.parameterResponse.prototype.setRoot = function(value) {
  jspb.Message.setWrapperField(this, 4, value);
};


proto.sparkmax.parameterResponse.prototype.clearRoot = function() {
  this.setRoot(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.parameterResponse.prototype.hasRoot = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional uint32 number = 5;
 * @return {number}
 */
proto.sparkmax.parameterResponse.prototype.getNumber = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.sparkmax.parameterResponse.prototype.setNumber = function(value) {
  jspb.Message.setProto3IntField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.parameterListRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.parameterListRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.parameterListRequest.displayName = 'proto.sparkmax.parameterListRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.parameterListRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.parameterListRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.parameterListRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.parameterListRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    root: (f = msg.getRoot()) && proto.sparkmax.rootCommand.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.parameterListRequest}
 */
proto.sparkmax.parameterListRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.parameterListRequest;
  return proto.sparkmax.parameterListRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.parameterListRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.parameterListRequest}
 */
proto.sparkmax.parameterListRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.sparkmax.rootCommand;
      reader.readMessage(value,proto.sparkmax.rootCommand.deserializeBinaryFromReader);
      msg.setRoot(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.parameterListRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.parameterListRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.parameterListRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.parameterListRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRoot();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.sparkmax.rootCommand.serializeBinaryToWriter
    );
  }
};


/**
 * optional rootCommand root = 1;
 * @return {?proto.sparkmax.rootCommand}
 */
proto.sparkmax.parameterListRequest.prototype.getRoot = function() {
  return /** @type{?proto.sparkmax.rootCommand} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.rootCommand, 1));
};


/** @param {?proto.sparkmax.rootCommand|undefined} value */
proto.sparkmax.parameterListRequest.prototype.setRoot = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.sparkmax.parameterListRequest.prototype.clearRoot = function() {
  this.setRoot(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.parameterListRequest.prototype.hasRoot = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.parameterListResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.sparkmax.parameterListResponse.repeatedFields_, null);
};
goog.inherits(proto.sparkmax.parameterListResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.parameterListResponse.displayName = 'proto.sparkmax.parameterListResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.sparkmax.parameterListResponse.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.parameterListResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.parameterListResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.parameterListResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.parameterListResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    parametersList: jspb.Message.toObjectList(msg.getParametersList(),
    proto.sparkmax.parameterResponse.toObject, includeInstance),
    root: (f = msg.getRoot()) && proto.sparkmax.rootResponse.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.parameterListResponse}
 */
proto.sparkmax.parameterListResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.parameterListResponse;
  return proto.sparkmax.parameterListResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.parameterListResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.parameterListResponse}
 */
proto.sparkmax.parameterListResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.sparkmax.parameterResponse;
      reader.readMessage(value,proto.sparkmax.parameterResponse.deserializeBinaryFromReader);
      msg.addParameters(value);
      break;
    case 3:
      var value = new proto.sparkmax.rootResponse;
      reader.readMessage(value,proto.sparkmax.rootResponse.deserializeBinaryFromReader);
      msg.setRoot(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.parameterListResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.parameterListResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.parameterListResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.parameterListResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getParametersList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.sparkmax.parameterResponse.serializeBinaryToWriter
    );
  }
  f = message.getRoot();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.sparkmax.rootResponse.serializeBinaryToWriter
    );
  }
};


/**
 * repeated parameterResponse parameters = 1;
 * @return {!Array<!proto.sparkmax.parameterResponse>}
 */
proto.sparkmax.parameterListResponse.prototype.getParametersList = function() {
  return /** @type{!Array<!proto.sparkmax.parameterResponse>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.sparkmax.parameterResponse, 1));
};


/** @param {!Array<!proto.sparkmax.parameterResponse>} value */
proto.sparkmax.parameterListResponse.prototype.setParametersList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.sparkmax.parameterResponse=} opt_value
 * @param {number=} opt_index
 * @return {!proto.sparkmax.parameterResponse}
 */
proto.sparkmax.parameterListResponse.prototype.addParameters = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.sparkmax.parameterResponse, opt_index);
};


proto.sparkmax.parameterListResponse.prototype.clearParametersList = function() {
  this.setParametersList([]);
};


/**
 * optional rootResponse root = 3;
 * @return {?proto.sparkmax.rootResponse}
 */
proto.sparkmax.parameterListResponse.prototype.getRoot = function() {
  return /** @type{?proto.sparkmax.rootResponse} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.rootResponse, 3));
};


/** @param {?proto.sparkmax.rootResponse|undefined} value */
proto.sparkmax.parameterListResponse.prototype.setRoot = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.sparkmax.parameterListResponse.prototype.clearRoot = function() {
  this.setRoot(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.parameterListResponse.prototype.hasRoot = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.setpointRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.setpointRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.setpointRequest.displayName = 'proto.sparkmax.setpointRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.setpointRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.setpointRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.setpointRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.setpointRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    root: (f = msg.getRoot()) && proto.sparkmax.rootCommand.toObject(includeInstance, f),
    setpoint: +jspb.Message.getFieldWithDefault(msg, 2, 0.0),
    enable: jspb.Message.getFieldWithDefault(msg, 3, false),
    auxsetpoint: +jspb.Message.getFieldWithDefault(msg, 5, 0.0),
    pidslot: jspb.Message.getFieldWithDefault(msg, 6, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.setpointRequest}
 */
proto.sparkmax.setpointRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.setpointRequest;
  return proto.sparkmax.setpointRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.setpointRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.setpointRequest}
 */
proto.sparkmax.setpointRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.sparkmax.rootCommand;
      reader.readMessage(value,proto.sparkmax.rootCommand.deserializeBinaryFromReader);
      msg.setRoot(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setSetpoint(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setEnable(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setAuxsetpoint(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setPidslot(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.setpointRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.setpointRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.setpointRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.setpointRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRoot();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.sparkmax.rootCommand.serializeBinaryToWriter
    );
  }
  f = message.getSetpoint();
  if (f !== 0.0) {
    writer.writeFloat(
      2,
      f
    );
  }
  f = message.getEnable();
  if (f) {
    writer.writeBool(
      3,
      f
    );
  }
  f = message.getAuxsetpoint();
  if (f !== 0.0) {
    writer.writeFloat(
      5,
      f
    );
  }
  f = message.getPidslot();
  if (f !== 0) {
    writer.writeUint32(
      6,
      f
    );
  }
};


/**
 * optional rootCommand root = 1;
 * @return {?proto.sparkmax.rootCommand}
 */
proto.sparkmax.setpointRequest.prototype.getRoot = function() {
  return /** @type{?proto.sparkmax.rootCommand} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.rootCommand, 1));
};


/** @param {?proto.sparkmax.rootCommand|undefined} value */
proto.sparkmax.setpointRequest.prototype.setRoot = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.sparkmax.setpointRequest.prototype.clearRoot = function() {
  this.setRoot(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.setpointRequest.prototype.hasRoot = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional float setpoint = 2;
 * @return {number}
 */
proto.sparkmax.setpointRequest.prototype.getSetpoint = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 2, 0.0));
};


/** @param {number} value */
proto.sparkmax.setpointRequest.prototype.setSetpoint = function(value) {
  jspb.Message.setProto3FloatField(this, 2, value);
};


/**
 * optional bool enable = 3;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.setpointRequest.prototype.getEnable = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 3, false));
};


/** @param {boolean} value */
proto.sparkmax.setpointRequest.prototype.setEnable = function(value) {
  jspb.Message.setProto3BooleanField(this, 3, value);
};


/**
 * optional float auxSetpoint = 5;
 * @return {number}
 */
proto.sparkmax.setpointRequest.prototype.getAuxsetpoint = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 5, 0.0));
};


/** @param {number} value */
proto.sparkmax.setpointRequest.prototype.setAuxsetpoint = function(value) {
  jspb.Message.setProto3FloatField(this, 5, value);
};


/**
 * optional uint32 pidSlot = 6;
 * @return {number}
 */
proto.sparkmax.setpointRequest.prototype.getPidslot = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.sparkmax.setpointRequest.prototype.setPidslot = function(value) {
  jspb.Message.setProto3IntField(this, 6, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.setpointResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.setpointResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.setpointResponse.displayName = 'proto.sparkmax.setpointResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.setpointResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.setpointResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.setpointResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.setpointResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    setpoint: +jspb.Message.getFieldWithDefault(msg, 1, 0.0),
    isrunning: jspb.Message.getFieldWithDefault(msg, 2, false),
    root: (f = msg.getRoot()) && proto.sparkmax.rootResponse.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.setpointResponse}
 */
proto.sparkmax.setpointResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.setpointResponse;
  return proto.sparkmax.setpointResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.setpointResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.setpointResponse}
 */
proto.sparkmax.setpointResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setSetpoint(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsrunning(value);
      break;
    case 3:
      var value = new proto.sparkmax.rootResponse;
      reader.readMessage(value,proto.sparkmax.rootResponse.deserializeBinaryFromReader);
      msg.setRoot(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.setpointResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.setpointResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.setpointResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.setpointResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSetpoint();
  if (f !== 0.0) {
    writer.writeFloat(
      1,
      f
    );
  }
  f = message.getIsrunning();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
  f = message.getRoot();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.sparkmax.rootResponse.serializeBinaryToWriter
    );
  }
};


/**
 * optional float setpoint = 1;
 * @return {number}
 */
proto.sparkmax.setpointResponse.prototype.getSetpoint = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 1, 0.0));
};


/** @param {number} value */
proto.sparkmax.setpointResponse.prototype.setSetpoint = function(value) {
  jspb.Message.setProto3FloatField(this, 1, value);
};


/**
 * optional bool isRunning = 2;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.setpointResponse.prototype.getIsrunning = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 2, false));
};


/** @param {boolean} value */
proto.sparkmax.setpointResponse.prototype.setIsrunning = function(value) {
  jspb.Message.setProto3BooleanField(this, 2, value);
};


/**
 * optional rootResponse root = 3;
 * @return {?proto.sparkmax.rootResponse}
 */
proto.sparkmax.setpointResponse.prototype.getRoot = function() {
  return /** @type{?proto.sparkmax.rootResponse} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.rootResponse, 3));
};


/** @param {?proto.sparkmax.rootResponse|undefined} value */
proto.sparkmax.setpointResponse.prototype.setRoot = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.sparkmax.setpointResponse.prototype.clearRoot = function() {
  this.setRoot(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.setpointResponse.prototype.hasRoot = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.followerRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.followerRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.followerRequest.displayName = 'proto.sparkmax.followerRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.followerRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.followerRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.followerRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.followerRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    root: (f = msg.getRoot()) && proto.sparkmax.rootCommand.toObject(includeInstance, f),
    followerid: jspb.Message.getFieldWithDefault(msg, 2, 0),
    followerconfig: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.followerRequest}
 */
proto.sparkmax.followerRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.followerRequest;
  return proto.sparkmax.followerRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.followerRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.followerRequest}
 */
proto.sparkmax.followerRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.sparkmax.rootCommand;
      reader.readMessage(value,proto.sparkmax.rootCommand.deserializeBinaryFromReader);
      msg.setRoot(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setFollowerid(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setFollowerconfig(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.followerRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.followerRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.followerRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.followerRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRoot();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.sparkmax.rootCommand.serializeBinaryToWriter
    );
  }
  f = message.getFollowerid();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = message.getFollowerconfig();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
};


/**
 * optional rootCommand root = 1;
 * @return {?proto.sparkmax.rootCommand}
 */
proto.sparkmax.followerRequest.prototype.getRoot = function() {
  return /** @type{?proto.sparkmax.rootCommand} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.rootCommand, 1));
};


/** @param {?proto.sparkmax.rootCommand|undefined} value */
proto.sparkmax.followerRequest.prototype.setRoot = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.sparkmax.followerRequest.prototype.clearRoot = function() {
  this.setRoot(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.followerRequest.prototype.hasRoot = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional uint32 followerid = 2;
 * @return {number}
 */
proto.sparkmax.followerRequest.prototype.getFollowerid = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.sparkmax.followerRequest.prototype.setFollowerid = function(value) {
  jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional uint32 followerconfig = 3;
 * @return {number}
 */
proto.sparkmax.followerRequest.prototype.getFollowerconfig = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.sparkmax.followerRequest.prototype.setFollowerconfig = function(value) {
  jspb.Message.setProto3IntField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.clearFaultsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.clearFaultsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.clearFaultsRequest.displayName = 'proto.sparkmax.clearFaultsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.clearFaultsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.clearFaultsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.clearFaultsRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.clearFaultsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    root: (f = msg.getRoot()) && proto.sparkmax.rootCommand.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.clearFaultsRequest}
 */
proto.sparkmax.clearFaultsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.clearFaultsRequest;
  return proto.sparkmax.clearFaultsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.clearFaultsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.clearFaultsRequest}
 */
proto.sparkmax.clearFaultsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.sparkmax.rootCommand;
      reader.readMessage(value,proto.sparkmax.rootCommand.deserializeBinaryFromReader);
      msg.setRoot(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.clearFaultsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.clearFaultsRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.clearFaultsRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.clearFaultsRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRoot();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.sparkmax.rootCommand.serializeBinaryToWriter
    );
  }
};


/**
 * optional rootCommand root = 1;
 * @return {?proto.sparkmax.rootCommand}
 */
proto.sparkmax.clearFaultsRequest.prototype.getRoot = function() {
  return /** @type{?proto.sparkmax.rootCommand} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.rootCommand, 1));
};


/** @param {?proto.sparkmax.rootCommand|undefined} value */
proto.sparkmax.clearFaultsRequest.prototype.setRoot = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.sparkmax.clearFaultsRequest.prototype.clearRoot = function() {
  this.setRoot(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.clearFaultsRequest.prototype.hasRoot = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.clearFaultsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.clearFaultsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.clearFaultsResponse.displayName = 'proto.sparkmax.clearFaultsResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.clearFaultsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.clearFaultsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.clearFaultsResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.clearFaultsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    root: (f = msg.getRoot()) && proto.sparkmax.rootResponse.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.clearFaultsResponse}
 */
proto.sparkmax.clearFaultsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.clearFaultsResponse;
  return proto.sparkmax.clearFaultsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.clearFaultsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.clearFaultsResponse}
 */
proto.sparkmax.clearFaultsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.sparkmax.rootResponse;
      reader.readMessage(value,proto.sparkmax.rootResponse.deserializeBinaryFromReader);
      msg.setRoot(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.clearFaultsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.clearFaultsResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.clearFaultsResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.clearFaultsResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRoot();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.sparkmax.rootResponse.serializeBinaryToWriter
    );
  }
};


/**
 * optional rootResponse root = 1;
 * @return {?proto.sparkmax.rootResponse}
 */
proto.sparkmax.clearFaultsResponse.prototype.getRoot = function() {
  return /** @type{?proto.sparkmax.rootResponse} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.rootResponse, 1));
};


/** @param {?proto.sparkmax.rootResponse|undefined} value */
proto.sparkmax.clearFaultsResponse.prototype.setRoot = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.sparkmax.clearFaultsResponse.prototype.clearRoot = function() {
  this.setRoot(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.clearFaultsResponse.prototype.hasRoot = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.DRVStatusRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.DRVStatusRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.DRVStatusRequest.displayName = 'proto.sparkmax.DRVStatusRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.DRVStatusRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.DRVStatusRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.DRVStatusRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.DRVStatusRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    root: (f = msg.getRoot()) && proto.sparkmax.rootCommand.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.DRVStatusRequest}
 */
proto.sparkmax.DRVStatusRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.DRVStatusRequest;
  return proto.sparkmax.DRVStatusRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.DRVStatusRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.DRVStatusRequest}
 */
proto.sparkmax.DRVStatusRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.sparkmax.rootCommand;
      reader.readMessage(value,proto.sparkmax.rootCommand.deserializeBinaryFromReader);
      msg.setRoot(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.DRVStatusRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.DRVStatusRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.DRVStatusRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.DRVStatusRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRoot();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.sparkmax.rootCommand.serializeBinaryToWriter
    );
  }
};


/**
 * optional rootCommand root = 1;
 * @return {?proto.sparkmax.rootCommand}
 */
proto.sparkmax.DRVStatusRequest.prototype.getRoot = function() {
  return /** @type{?proto.sparkmax.rootCommand} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.rootCommand, 1));
};


/** @param {?proto.sparkmax.rootCommand|undefined} value */
proto.sparkmax.DRVStatusRequest.prototype.setRoot = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.sparkmax.DRVStatusRequest.prototype.clearRoot = function() {
  this.setRoot(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.DRVStatusRequest.prototype.hasRoot = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.DRVStatusResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.DRVStatusResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.DRVStatusResponse.displayName = 'proto.sparkmax.DRVStatusResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.DRVStatusResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.DRVStatusResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.DRVStatusResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.DRVStatusResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    stat0: (f = msg.getStat0()) && proto.sparkmax.DRVStat0.toObject(includeInstance, f),
    stat1: (f = msg.getStat1()) && proto.sparkmax.DRVStat1.toObject(includeInstance, f),
    root: (f = msg.getRoot()) && proto.sparkmax.rootResponse.toObject(includeInstance, f),
    faults: (f = msg.getFaults()) && proto.sparkmax.FaultFlags.toObject(includeInstance, f),
    stickyfaults: (f = msg.getStickyfaults()) && proto.sparkmax.FaultFlags.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.DRVStatusResponse}
 */
proto.sparkmax.DRVStatusResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.DRVStatusResponse;
  return proto.sparkmax.DRVStatusResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.DRVStatusResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.DRVStatusResponse}
 */
proto.sparkmax.DRVStatusResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.sparkmax.DRVStat0;
      reader.readMessage(value,proto.sparkmax.DRVStat0.deserializeBinaryFromReader);
      msg.setStat0(value);
      break;
    case 2:
      var value = new proto.sparkmax.DRVStat1;
      reader.readMessage(value,proto.sparkmax.DRVStat1.deserializeBinaryFromReader);
      msg.setStat1(value);
      break;
    case 3:
      var value = new proto.sparkmax.rootResponse;
      reader.readMessage(value,proto.sparkmax.rootResponse.deserializeBinaryFromReader);
      msg.setRoot(value);
      break;
    case 4:
      var value = new proto.sparkmax.FaultFlags;
      reader.readMessage(value,proto.sparkmax.FaultFlags.deserializeBinaryFromReader);
      msg.setFaults(value);
      break;
    case 5:
      var value = new proto.sparkmax.FaultFlags;
      reader.readMessage(value,proto.sparkmax.FaultFlags.deserializeBinaryFromReader);
      msg.setStickyfaults(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.DRVStatusResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.DRVStatusResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.DRVStatusResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.DRVStatusResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getStat0();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.sparkmax.DRVStat0.serializeBinaryToWriter
    );
  }
  f = message.getStat1();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.sparkmax.DRVStat1.serializeBinaryToWriter
    );
  }
  f = message.getRoot();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.sparkmax.rootResponse.serializeBinaryToWriter
    );
  }
  f = message.getFaults();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.sparkmax.FaultFlags.serializeBinaryToWriter
    );
  }
  f = message.getStickyfaults();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.sparkmax.FaultFlags.serializeBinaryToWriter
    );
  }
};


/**
 * optional DRVStat0 stat0 = 1;
 * @return {?proto.sparkmax.DRVStat0}
 */
proto.sparkmax.DRVStatusResponse.prototype.getStat0 = function() {
  return /** @type{?proto.sparkmax.DRVStat0} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.DRVStat0, 1));
};


/** @param {?proto.sparkmax.DRVStat0|undefined} value */
proto.sparkmax.DRVStatusResponse.prototype.setStat0 = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.sparkmax.DRVStatusResponse.prototype.clearStat0 = function() {
  this.setStat0(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.DRVStatusResponse.prototype.hasStat0 = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional DRVStat1 stat1 = 2;
 * @return {?proto.sparkmax.DRVStat1}
 */
proto.sparkmax.DRVStatusResponse.prototype.getStat1 = function() {
  return /** @type{?proto.sparkmax.DRVStat1} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.DRVStat1, 2));
};


/** @param {?proto.sparkmax.DRVStat1|undefined} value */
proto.sparkmax.DRVStatusResponse.prototype.setStat1 = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.sparkmax.DRVStatusResponse.prototype.clearStat1 = function() {
  this.setStat1(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.DRVStatusResponse.prototype.hasStat1 = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional rootResponse root = 3;
 * @return {?proto.sparkmax.rootResponse}
 */
proto.sparkmax.DRVStatusResponse.prototype.getRoot = function() {
  return /** @type{?proto.sparkmax.rootResponse} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.rootResponse, 3));
};


/** @param {?proto.sparkmax.rootResponse|undefined} value */
proto.sparkmax.DRVStatusResponse.prototype.setRoot = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.sparkmax.DRVStatusResponse.prototype.clearRoot = function() {
  this.setRoot(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.DRVStatusResponse.prototype.hasRoot = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional FaultFlags faults = 4;
 * @return {?proto.sparkmax.FaultFlags}
 */
proto.sparkmax.DRVStatusResponse.prototype.getFaults = function() {
  return /** @type{?proto.sparkmax.FaultFlags} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.FaultFlags, 4));
};


/** @param {?proto.sparkmax.FaultFlags|undefined} value */
proto.sparkmax.DRVStatusResponse.prototype.setFaults = function(value) {
  jspb.Message.setWrapperField(this, 4, value);
};


proto.sparkmax.DRVStatusResponse.prototype.clearFaults = function() {
  this.setFaults(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.DRVStatusResponse.prototype.hasFaults = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional FaultFlags stickyFaults = 5;
 * @return {?proto.sparkmax.FaultFlags}
 */
proto.sparkmax.DRVStatusResponse.prototype.getStickyfaults = function() {
  return /** @type{?proto.sparkmax.FaultFlags} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.FaultFlags, 5));
};


/** @param {?proto.sparkmax.FaultFlags|undefined} value */
proto.sparkmax.DRVStatusResponse.prototype.setStickyfaults = function(value) {
  jspb.Message.setWrapperField(this, 5, value);
};


proto.sparkmax.DRVStatusResponse.prototype.clearStickyfaults = function() {
  this.setStickyfaults(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.DRVStatusResponse.prototype.hasStickyfaults = function() {
  return jspb.Message.getField(this, 5) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.FaultFlags = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.FaultFlags, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.FaultFlags.displayName = 'proto.sparkmax.FaultFlags';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.FaultFlags.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.FaultFlags.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.FaultFlags} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.FaultFlags.toObject = function(includeInstance, msg) {
  var f, obj = {
    brownout: jspb.Message.getFieldWithDefault(msg, 1, false),
    overcurrent: jspb.Message.getFieldWithDefault(msg, 2, false),
    iwdtreset: jspb.Message.getFieldWithDefault(msg, 3, false),
    motorfault: jspb.Message.getFieldWithDefault(msg, 4, false),
    sensorfault: jspb.Message.getFieldWithDefault(msg, 5, false),
    stall: jspb.Message.getFieldWithDefault(msg, 6, false),
    eepromcrc: jspb.Message.getFieldWithDefault(msg, 7, false),
    cantx: jspb.Message.getFieldWithDefault(msg, 8, false),
    canrx: jspb.Message.getFieldWithDefault(msg, 9, false),
    hasreset: jspb.Message.getFieldWithDefault(msg, 10, false),
    drvfault: jspb.Message.getFieldWithDefault(msg, 11, false),
    otherfault: jspb.Message.getFieldWithDefault(msg, 12, false),
    softlimitfwd: jspb.Message.getFieldWithDefault(msg, 13, false),
    softlimitrev: jspb.Message.getFieldWithDefault(msg, 14, false),
    hardlimitfwd: jspb.Message.getFieldWithDefault(msg, 15, false),
    hardlimitrev: jspb.Message.getFieldWithDefault(msg, 16, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.FaultFlags}
 */
proto.sparkmax.FaultFlags.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.FaultFlags;
  return proto.sparkmax.FaultFlags.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.FaultFlags} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.FaultFlags}
 */
proto.sparkmax.FaultFlags.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setBrownout(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setOvercurrent(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIwdtreset(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setMotorfault(value);
      break;
    case 5:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSensorfault(value);
      break;
    case 6:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setStall(value);
      break;
    case 7:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setEepromcrc(value);
      break;
    case 8:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setCantx(value);
      break;
    case 9:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setCanrx(value);
      break;
    case 10:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setHasreset(value);
      break;
    case 11:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setDrvfault(value);
      break;
    case 12:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setOtherfault(value);
      break;
    case 13:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSoftlimitfwd(value);
      break;
    case 14:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSoftlimitrev(value);
      break;
    case 15:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setHardlimitfwd(value);
      break;
    case 16:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setHardlimitrev(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.FaultFlags.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.FaultFlags.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.FaultFlags} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.FaultFlags.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getBrownout();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
  f = message.getOvercurrent();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
  f = message.getIwdtreset();
  if (f) {
    writer.writeBool(
      3,
      f
    );
  }
  f = message.getMotorfault();
  if (f) {
    writer.writeBool(
      4,
      f
    );
  }
  f = message.getSensorfault();
  if (f) {
    writer.writeBool(
      5,
      f
    );
  }
  f = message.getStall();
  if (f) {
    writer.writeBool(
      6,
      f
    );
  }
  f = message.getEepromcrc();
  if (f) {
    writer.writeBool(
      7,
      f
    );
  }
  f = message.getCantx();
  if (f) {
    writer.writeBool(
      8,
      f
    );
  }
  f = message.getCanrx();
  if (f) {
    writer.writeBool(
      9,
      f
    );
  }
  f = message.getHasreset();
  if (f) {
    writer.writeBool(
      10,
      f
    );
  }
  f = message.getDrvfault();
  if (f) {
    writer.writeBool(
      11,
      f
    );
  }
  f = message.getOtherfault();
  if (f) {
    writer.writeBool(
      12,
      f
    );
  }
  f = message.getSoftlimitfwd();
  if (f) {
    writer.writeBool(
      13,
      f
    );
  }
  f = message.getSoftlimitrev();
  if (f) {
    writer.writeBool(
      14,
      f
    );
  }
  f = message.getHardlimitfwd();
  if (f) {
    writer.writeBool(
      15,
      f
    );
  }
  f = message.getHardlimitrev();
  if (f) {
    writer.writeBool(
      16,
      f
    );
  }
};


/**
 * optional bool Brownout = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.FaultFlags.prototype.getBrownout = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.sparkmax.FaultFlags.prototype.setBrownout = function(value) {
  jspb.Message.setProto3BooleanField(this, 1, value);
};


/**
 * optional bool Overcurrent = 2;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.FaultFlags.prototype.getOvercurrent = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 2, false));
};


/** @param {boolean} value */
proto.sparkmax.FaultFlags.prototype.setOvercurrent = function(value) {
  jspb.Message.setProto3BooleanField(this, 2, value);
};


/**
 * optional bool IWDTReset = 3;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.FaultFlags.prototype.getIwdtreset = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 3, false));
};


/** @param {boolean} value */
proto.sparkmax.FaultFlags.prototype.setIwdtreset = function(value) {
  jspb.Message.setProto3BooleanField(this, 3, value);
};


/**
 * optional bool MotorFault = 4;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.FaultFlags.prototype.getMotorfault = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 4, false));
};


/** @param {boolean} value */
proto.sparkmax.FaultFlags.prototype.setMotorfault = function(value) {
  jspb.Message.setProto3BooleanField(this, 4, value);
};


/**
 * optional bool SensorFault = 5;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.FaultFlags.prototype.getSensorfault = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 5, false));
};


/** @param {boolean} value */
proto.sparkmax.FaultFlags.prototype.setSensorfault = function(value) {
  jspb.Message.setProto3BooleanField(this, 5, value);
};


/**
 * optional bool Stall = 6;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.FaultFlags.prototype.getStall = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 6, false));
};


/** @param {boolean} value */
proto.sparkmax.FaultFlags.prototype.setStall = function(value) {
  jspb.Message.setProto3BooleanField(this, 6, value);
};


/**
 * optional bool EEPROMCRC = 7;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.FaultFlags.prototype.getEepromcrc = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 7, false));
};


/** @param {boolean} value */
proto.sparkmax.FaultFlags.prototype.setEepromcrc = function(value) {
  jspb.Message.setProto3BooleanField(this, 7, value);
};


/**
 * optional bool CANTX = 8;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.FaultFlags.prototype.getCantx = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 8, false));
};


/** @param {boolean} value */
proto.sparkmax.FaultFlags.prototype.setCantx = function(value) {
  jspb.Message.setProto3BooleanField(this, 8, value);
};


/**
 * optional bool CANRX = 9;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.FaultFlags.prototype.getCanrx = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 9, false));
};


/** @param {boolean} value */
proto.sparkmax.FaultFlags.prototype.setCanrx = function(value) {
  jspb.Message.setProto3BooleanField(this, 9, value);
};


/**
 * optional bool HasReset = 10;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.FaultFlags.prototype.getHasreset = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 10, false));
};


/** @param {boolean} value */
proto.sparkmax.FaultFlags.prototype.setHasreset = function(value) {
  jspb.Message.setProto3BooleanField(this, 10, value);
};


/**
 * optional bool DRVFault = 11;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.FaultFlags.prototype.getDrvfault = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 11, false));
};


/** @param {boolean} value */
proto.sparkmax.FaultFlags.prototype.setDrvfault = function(value) {
  jspb.Message.setProto3BooleanField(this, 11, value);
};


/**
 * optional bool OtherFault = 12;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.FaultFlags.prototype.getOtherfault = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 12, false));
};


/** @param {boolean} value */
proto.sparkmax.FaultFlags.prototype.setOtherfault = function(value) {
  jspb.Message.setProto3BooleanField(this, 12, value);
};


/**
 * optional bool SoftLimitFwd = 13;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.FaultFlags.prototype.getSoftlimitfwd = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 13, false));
};


/** @param {boolean} value */
proto.sparkmax.FaultFlags.prototype.setSoftlimitfwd = function(value) {
  jspb.Message.setProto3BooleanField(this, 13, value);
};


/**
 * optional bool SoftLimitRev = 14;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.FaultFlags.prototype.getSoftlimitrev = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 14, false));
};


/** @param {boolean} value */
proto.sparkmax.FaultFlags.prototype.setSoftlimitrev = function(value) {
  jspb.Message.setProto3BooleanField(this, 14, value);
};


/**
 * optional bool HardLimitFwd = 15;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.FaultFlags.prototype.getHardlimitfwd = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 15, false));
};


/** @param {boolean} value */
proto.sparkmax.FaultFlags.prototype.setHardlimitfwd = function(value) {
  jspb.Message.setProto3BooleanField(this, 15, value);
};


/**
 * optional bool HardLimitRev = 16;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.FaultFlags.prototype.getHardlimitrev = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 16, false));
};


/** @param {boolean} value */
proto.sparkmax.FaultFlags.prototype.setHardlimitrev = function(value) {
  jspb.Message.setProto3BooleanField(this, 16, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.DRVStat0 = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.DRVStat0, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.DRVStat0.displayName = 'proto.sparkmax.DRVStat0';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.DRVStat0.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.DRVStat0.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.DRVStat0} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.DRVStat0.toObject = function(includeInstance, msg) {
  var f, obj = {
    vdsLc: jspb.Message.getFieldWithDefault(msg, 1, false),
    vdsHc: jspb.Message.getFieldWithDefault(msg, 2, false),
    vdsLb: jspb.Message.getFieldWithDefault(msg, 3, false),
    vdsHb: jspb.Message.getFieldWithDefault(msg, 4, false),
    vdsLa: jspb.Message.getFieldWithDefault(msg, 5, false),
    vdsHa: jspb.Message.getFieldWithDefault(msg, 6, false),
    otsd: jspb.Message.getFieldWithDefault(msg, 7, false),
    uvlo: jspb.Message.getFieldWithDefault(msg, 8, false),
    gdf: jspb.Message.getFieldWithDefault(msg, 9, false),
    vdsOcp: jspb.Message.getFieldWithDefault(msg, 10, false),
    fault: jspb.Message.getFieldWithDefault(msg, 11, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.DRVStat0}
 */
proto.sparkmax.DRVStat0.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.DRVStat0;
  return proto.sparkmax.DRVStat0.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.DRVStat0} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.DRVStat0}
 */
proto.sparkmax.DRVStat0.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setVdsLc(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setVdsHc(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setVdsLb(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setVdsHb(value);
      break;
    case 5:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setVdsLa(value);
      break;
    case 6:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setVdsHa(value);
      break;
    case 7:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setOtsd(value);
      break;
    case 8:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setUvlo(value);
      break;
    case 9:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setGdf(value);
      break;
    case 10:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setVdsOcp(value);
      break;
    case 11:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setFault(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.DRVStat0.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.DRVStat0.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.DRVStat0} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.DRVStat0.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getVdsLc();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
  f = message.getVdsHc();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
  f = message.getVdsLb();
  if (f) {
    writer.writeBool(
      3,
      f
    );
  }
  f = message.getVdsHb();
  if (f) {
    writer.writeBool(
      4,
      f
    );
  }
  f = message.getVdsLa();
  if (f) {
    writer.writeBool(
      5,
      f
    );
  }
  f = message.getVdsHa();
  if (f) {
    writer.writeBool(
      6,
      f
    );
  }
  f = message.getOtsd();
  if (f) {
    writer.writeBool(
      7,
      f
    );
  }
  f = message.getUvlo();
  if (f) {
    writer.writeBool(
      8,
      f
    );
  }
  f = message.getGdf();
  if (f) {
    writer.writeBool(
      9,
      f
    );
  }
  f = message.getVdsOcp();
  if (f) {
    writer.writeBool(
      10,
      f
    );
  }
  f = message.getFault();
  if (f) {
    writer.writeBool(
      11,
      f
    );
  }
};


/**
 * optional bool VDS_LC = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.DRVStat0.prototype.getVdsLc = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.sparkmax.DRVStat0.prototype.setVdsLc = function(value) {
  jspb.Message.setProto3BooleanField(this, 1, value);
};


/**
 * optional bool VDS_HC = 2;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.DRVStat0.prototype.getVdsHc = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 2, false));
};


/** @param {boolean} value */
proto.sparkmax.DRVStat0.prototype.setVdsHc = function(value) {
  jspb.Message.setProto3BooleanField(this, 2, value);
};


/**
 * optional bool VDS_LB = 3;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.DRVStat0.prototype.getVdsLb = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 3, false));
};


/** @param {boolean} value */
proto.sparkmax.DRVStat0.prototype.setVdsLb = function(value) {
  jspb.Message.setProto3BooleanField(this, 3, value);
};


/**
 * optional bool VDS_HB = 4;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.DRVStat0.prototype.getVdsHb = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 4, false));
};


/** @param {boolean} value */
proto.sparkmax.DRVStat0.prototype.setVdsHb = function(value) {
  jspb.Message.setProto3BooleanField(this, 4, value);
};


/**
 * optional bool VDS_LA = 5;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.DRVStat0.prototype.getVdsLa = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 5, false));
};


/** @param {boolean} value */
proto.sparkmax.DRVStat0.prototype.setVdsLa = function(value) {
  jspb.Message.setProto3BooleanField(this, 5, value);
};


/**
 * optional bool VDS_HA = 6;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.DRVStat0.prototype.getVdsHa = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 6, false));
};


/** @param {boolean} value */
proto.sparkmax.DRVStat0.prototype.setVdsHa = function(value) {
  jspb.Message.setProto3BooleanField(this, 6, value);
};


/**
 * optional bool OTSD = 7;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.DRVStat0.prototype.getOtsd = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 7, false));
};


/** @param {boolean} value */
proto.sparkmax.DRVStat0.prototype.setOtsd = function(value) {
  jspb.Message.setProto3BooleanField(this, 7, value);
};


/**
 * optional bool UVLO = 8;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.DRVStat0.prototype.getUvlo = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 8, false));
};


/** @param {boolean} value */
proto.sparkmax.DRVStat0.prototype.setUvlo = function(value) {
  jspb.Message.setProto3BooleanField(this, 8, value);
};


/**
 * optional bool GDF = 9;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.DRVStat0.prototype.getGdf = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 9, false));
};


/** @param {boolean} value */
proto.sparkmax.DRVStat0.prototype.setGdf = function(value) {
  jspb.Message.setProto3BooleanField(this, 9, value);
};


/**
 * optional bool VDS_OCP = 10;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.DRVStat0.prototype.getVdsOcp = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 10, false));
};


/** @param {boolean} value */
proto.sparkmax.DRVStat0.prototype.setVdsOcp = function(value) {
  jspb.Message.setProto3BooleanField(this, 10, value);
};


/**
 * optional bool FAULT = 11;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.DRVStat0.prototype.getFault = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 11, false));
};


/** @param {boolean} value */
proto.sparkmax.DRVStat0.prototype.setFault = function(value) {
  jspb.Message.setProto3BooleanField(this, 11, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.DRVStat1 = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.DRVStat1, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.DRVStat1.displayName = 'proto.sparkmax.DRVStat1';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.DRVStat1.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.DRVStat1.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.DRVStat1} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.DRVStat1.toObject = function(includeInstance, msg) {
  var f, obj = {
    vgsLc: jspb.Message.getFieldWithDefault(msg, 1, false),
    vgsHc: jspb.Message.getFieldWithDefault(msg, 2, false),
    vgsLb: jspb.Message.getFieldWithDefault(msg, 3, false),
    vgsHb: jspb.Message.getFieldWithDefault(msg, 4, false),
    vgsLa: jspb.Message.getFieldWithDefault(msg, 5, false),
    vgsHa: jspb.Message.getFieldWithDefault(msg, 6, false),
    cpuv: jspb.Message.getFieldWithDefault(msg, 7, false),
    otw: jspb.Message.getFieldWithDefault(msg, 8, false),
    scOc: jspb.Message.getFieldWithDefault(msg, 9, false),
    sbOc: jspb.Message.getFieldWithDefault(msg, 10, false),
    saOc: jspb.Message.getFieldWithDefault(msg, 11, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.DRVStat1}
 */
proto.sparkmax.DRVStat1.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.DRVStat1;
  return proto.sparkmax.DRVStat1.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.DRVStat1} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.DRVStat1}
 */
proto.sparkmax.DRVStat1.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setVgsLc(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setVgsHc(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setVgsLb(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setVgsHb(value);
      break;
    case 5:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setVgsLa(value);
      break;
    case 6:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setVgsHa(value);
      break;
    case 7:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setCpuv(value);
      break;
    case 8:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setOtw(value);
      break;
    case 9:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setScOc(value);
      break;
    case 10:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSbOc(value);
      break;
    case 11:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSaOc(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.DRVStat1.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.DRVStat1.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.DRVStat1} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.DRVStat1.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getVgsLc();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
  f = message.getVgsHc();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
  f = message.getVgsLb();
  if (f) {
    writer.writeBool(
      3,
      f
    );
  }
  f = message.getVgsHb();
  if (f) {
    writer.writeBool(
      4,
      f
    );
  }
  f = message.getVgsLa();
  if (f) {
    writer.writeBool(
      5,
      f
    );
  }
  f = message.getVgsHa();
  if (f) {
    writer.writeBool(
      6,
      f
    );
  }
  f = message.getCpuv();
  if (f) {
    writer.writeBool(
      7,
      f
    );
  }
  f = message.getOtw();
  if (f) {
    writer.writeBool(
      8,
      f
    );
  }
  f = message.getScOc();
  if (f) {
    writer.writeBool(
      9,
      f
    );
  }
  f = message.getSbOc();
  if (f) {
    writer.writeBool(
      10,
      f
    );
  }
  f = message.getSaOc();
  if (f) {
    writer.writeBool(
      11,
      f
    );
  }
};


/**
 * optional bool VGS_LC = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.DRVStat1.prototype.getVgsLc = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.sparkmax.DRVStat1.prototype.setVgsLc = function(value) {
  jspb.Message.setProto3BooleanField(this, 1, value);
};


/**
 * optional bool VGS_HC = 2;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.DRVStat1.prototype.getVgsHc = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 2, false));
};


/** @param {boolean} value */
proto.sparkmax.DRVStat1.prototype.setVgsHc = function(value) {
  jspb.Message.setProto3BooleanField(this, 2, value);
};


/**
 * optional bool VGS_LB = 3;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.DRVStat1.prototype.getVgsLb = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 3, false));
};


/** @param {boolean} value */
proto.sparkmax.DRVStat1.prototype.setVgsLb = function(value) {
  jspb.Message.setProto3BooleanField(this, 3, value);
};


/**
 * optional bool VGS_HB = 4;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.DRVStat1.prototype.getVgsHb = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 4, false));
};


/** @param {boolean} value */
proto.sparkmax.DRVStat1.prototype.setVgsHb = function(value) {
  jspb.Message.setProto3BooleanField(this, 4, value);
};


/**
 * optional bool VGS_LA = 5;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.DRVStat1.prototype.getVgsLa = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 5, false));
};


/** @param {boolean} value */
proto.sparkmax.DRVStat1.prototype.setVgsLa = function(value) {
  jspb.Message.setProto3BooleanField(this, 5, value);
};


/**
 * optional bool VGS_HA = 6;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.DRVStat1.prototype.getVgsHa = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 6, false));
};


/** @param {boolean} value */
proto.sparkmax.DRVStat1.prototype.setVgsHa = function(value) {
  jspb.Message.setProto3BooleanField(this, 6, value);
};


/**
 * optional bool CPUV = 7;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.DRVStat1.prototype.getCpuv = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 7, false));
};


/** @param {boolean} value */
proto.sparkmax.DRVStat1.prototype.setCpuv = function(value) {
  jspb.Message.setProto3BooleanField(this, 7, value);
};


/**
 * optional bool OTW = 8;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.DRVStat1.prototype.getOtw = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 8, false));
};


/** @param {boolean} value */
proto.sparkmax.DRVStat1.prototype.setOtw = function(value) {
  jspb.Message.setProto3BooleanField(this, 8, value);
};


/**
 * optional bool SC_OC = 9;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.DRVStat1.prototype.getScOc = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 9, false));
};


/** @param {boolean} value */
proto.sparkmax.DRVStat1.prototype.setScOc = function(value) {
  jspb.Message.setProto3BooleanField(this, 9, value);
};


/**
 * optional bool SB_OC = 10;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.DRVStat1.prototype.getSbOc = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 10, false));
};


/** @param {boolean} value */
proto.sparkmax.DRVStat1.prototype.setSbOc = function(value) {
  jspb.Message.setProto3BooleanField(this, 10, value);
};


/**
 * optional bool SA_OC = 11;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.DRVStat1.prototype.getSaOc = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 11, false));
};


/** @param {boolean} value */
proto.sparkmax.DRVStat1.prototype.setSaOc = function(value) {
  jspb.Message.setProto3BooleanField(this, 11, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.telemetryData = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.telemetryData, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.telemetryData.displayName = 'proto.sparkmax.telemetryData';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.telemetryData.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.telemetryData.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.telemetryData} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.telemetryData.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: jspb.Message.getFieldWithDefault(msg, 1, 0),
    value: +jspb.Message.getFieldWithDefault(msg, 2, 0.0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.telemetryData}
 */
proto.sparkmax.telemetryData.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.telemetryData;
  return proto.sparkmax.telemetryData.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.telemetryData} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.telemetryData}
 */
proto.sparkmax.telemetryData.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.sparkmax.telemetryId} */ (reader.readEnum());
      msg.setId(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.telemetryData.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.telemetryData.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.telemetryData} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.telemetryData.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getId();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getValue();
  if (f !== 0.0) {
    writer.writeFloat(
      2,
      f
    );
  }
};


/**
 * optional telemetryId id = 1;
 * @return {!proto.sparkmax.telemetryId}
 */
proto.sparkmax.telemetryData.prototype.getId = function() {
  return /** @type {!proto.sparkmax.telemetryId} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {!proto.sparkmax.telemetryId} value */
proto.sparkmax.telemetryData.prototype.setId = function(value) {
  jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional float value = 2;
 * @return {number}
 */
proto.sparkmax.telemetryData.prototype.getValue = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 2, 0.0));
};


/** @param {number} value */
proto.sparkmax.telemetryData.prototype.setValue = function(value) {
  jspb.Message.setProto3FloatField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.telemetryRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.telemetryRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.telemetryRequest.displayName = 'proto.sparkmax.telemetryRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.telemetryRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.telemetryRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.telemetryRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.telemetryRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    root: (f = msg.getRoot()) && proto.sparkmax.rootCommand.toObject(includeInstance, f),
    data: (f = msg.getData()) && proto.sparkmax.telemetryData.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.telemetryRequest}
 */
proto.sparkmax.telemetryRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.telemetryRequest;
  return proto.sparkmax.telemetryRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.telemetryRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.telemetryRequest}
 */
proto.sparkmax.telemetryRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.sparkmax.rootCommand;
      reader.readMessage(value,proto.sparkmax.rootCommand.deserializeBinaryFromReader);
      msg.setRoot(value);
      break;
    case 2:
      var value = new proto.sparkmax.telemetryData;
      reader.readMessage(value,proto.sparkmax.telemetryData.deserializeBinaryFromReader);
      msg.setData(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.telemetryRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.telemetryRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.telemetryRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.telemetryRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRoot();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.sparkmax.rootCommand.serializeBinaryToWriter
    );
  }
  f = message.getData();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.sparkmax.telemetryData.serializeBinaryToWriter
    );
  }
};


/**
 * optional rootCommand root = 1;
 * @return {?proto.sparkmax.rootCommand}
 */
proto.sparkmax.telemetryRequest.prototype.getRoot = function() {
  return /** @type{?proto.sparkmax.rootCommand} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.rootCommand, 1));
};


/** @param {?proto.sparkmax.rootCommand|undefined} value */
proto.sparkmax.telemetryRequest.prototype.setRoot = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.sparkmax.telemetryRequest.prototype.clearRoot = function() {
  this.setRoot(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.telemetryRequest.prototype.hasRoot = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional telemetryData data = 2;
 * @return {?proto.sparkmax.telemetryData}
 */
proto.sparkmax.telemetryRequest.prototype.getData = function() {
  return /** @type{?proto.sparkmax.telemetryData} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.telemetryData, 2));
};


/** @param {?proto.sparkmax.telemetryData|undefined} value */
proto.sparkmax.telemetryRequest.prototype.setData = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.sparkmax.telemetryRequest.prototype.clearData = function() {
  this.setData(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.telemetryRequest.prototype.hasData = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.telemetryResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.sparkmax.telemetryResponse.repeatedFields_, null);
};
goog.inherits(proto.sparkmax.telemetryResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.telemetryResponse.displayName = 'proto.sparkmax.telemetryResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.sparkmax.telemetryResponse.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.telemetryResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.telemetryResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.telemetryResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.telemetryResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    root: (f = msg.getRoot()) && proto.sparkmax.rootResponse.toObject(includeInstance, f),
    dataList: jspb.Message.toObjectList(msg.getDataList(),
    proto.sparkmax.telemetryData.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.telemetryResponse}
 */
proto.sparkmax.telemetryResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.telemetryResponse;
  return proto.sparkmax.telemetryResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.telemetryResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.telemetryResponse}
 */
proto.sparkmax.telemetryResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.sparkmax.rootResponse;
      reader.readMessage(value,proto.sparkmax.rootResponse.deserializeBinaryFromReader);
      msg.setRoot(value);
      break;
    case 2:
      var value = new proto.sparkmax.telemetryData;
      reader.readMessage(value,proto.sparkmax.telemetryData.deserializeBinaryFromReader);
      msg.addData(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.telemetryResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.telemetryResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.telemetryResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.telemetryResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRoot();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.sparkmax.rootResponse.serializeBinaryToWriter
    );
  }
  f = message.getDataList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.sparkmax.telemetryData.serializeBinaryToWriter
    );
  }
};


/**
 * optional rootResponse root = 1;
 * @return {?proto.sparkmax.rootResponse}
 */
proto.sparkmax.telemetryResponse.prototype.getRoot = function() {
  return /** @type{?proto.sparkmax.rootResponse} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.rootResponse, 1));
};


/** @param {?proto.sparkmax.rootResponse|undefined} value */
proto.sparkmax.telemetryResponse.prototype.setRoot = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.sparkmax.telemetryResponse.prototype.clearRoot = function() {
  this.setRoot(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.telemetryResponse.prototype.hasRoot = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * repeated telemetryData data = 2;
 * @return {!Array<!proto.sparkmax.telemetryData>}
 */
proto.sparkmax.telemetryResponse.prototype.getDataList = function() {
  return /** @type{!Array<!proto.sparkmax.telemetryData>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.sparkmax.telemetryData, 2));
};


/** @param {!Array<!proto.sparkmax.telemetryData>} value */
proto.sparkmax.telemetryResponse.prototype.setDataList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.sparkmax.telemetryData=} opt_value
 * @param {number=} opt_index
 * @return {!proto.sparkmax.telemetryData}
 */
proto.sparkmax.telemetryResponse.prototype.addData = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.sparkmax.telemetryData, opt_index);
};


proto.sparkmax.telemetryResponse.prototype.clearDataList = function() {
  this.setDataList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.factoryResetRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.factoryResetRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.factoryResetRequest.displayName = 'proto.sparkmax.factoryResetRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.factoryResetRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.factoryResetRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.factoryResetRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.factoryResetRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    root: (f = msg.getRoot()) && proto.sparkmax.rootCommand.toObject(includeInstance, f),
    fullwipe: jspb.Message.getFieldWithDefault(msg, 2, false),
    burnafterwrite: jspb.Message.getFieldWithDefault(msg, 3, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.factoryResetRequest}
 */
proto.sparkmax.factoryResetRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.factoryResetRequest;
  return proto.sparkmax.factoryResetRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.factoryResetRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.factoryResetRequest}
 */
proto.sparkmax.factoryResetRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.sparkmax.rootCommand;
      reader.readMessage(value,proto.sparkmax.rootCommand.deserializeBinaryFromReader);
      msg.setRoot(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setFullwipe(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setBurnafterwrite(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.factoryResetRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.factoryResetRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.factoryResetRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.factoryResetRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRoot();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.sparkmax.rootCommand.serializeBinaryToWriter
    );
  }
  f = message.getFullwipe();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
  f = message.getBurnafterwrite();
  if (f) {
    writer.writeBool(
      3,
      f
    );
  }
};


/**
 * optional rootCommand root = 1;
 * @return {?proto.sparkmax.rootCommand}
 */
proto.sparkmax.factoryResetRequest.prototype.getRoot = function() {
  return /** @type{?proto.sparkmax.rootCommand} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.rootCommand, 1));
};


/** @param {?proto.sparkmax.rootCommand|undefined} value */
proto.sparkmax.factoryResetRequest.prototype.setRoot = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.sparkmax.factoryResetRequest.prototype.clearRoot = function() {
  this.setRoot(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.factoryResetRequest.prototype.hasRoot = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bool fullWipe = 2;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.factoryResetRequest.prototype.getFullwipe = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 2, false));
};


/** @param {boolean} value */
proto.sparkmax.factoryResetRequest.prototype.setFullwipe = function(value) {
  jspb.Message.setProto3BooleanField(this, 2, value);
};


/**
 * optional bool burnAfterWrite = 3;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.sparkmax.factoryResetRequest.prototype.getBurnafterwrite = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 3, false));
};


/** @param {boolean} value */
proto.sparkmax.factoryResetRequest.prototype.setBurnafterwrite = function(value) {
  jspb.Message.setProto3BooleanField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.idAssignmentRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.idAssignmentRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.idAssignmentRequest.displayName = 'proto.sparkmax.idAssignmentRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.idAssignmentRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.idAssignmentRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.idAssignmentRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.idAssignmentRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    root: (f = msg.getRoot()) && proto.sparkmax.rootCommand.toObject(includeInstance, f),
    uniqueid: jspb.Message.getFieldWithDefault(msg, 2, 0),
    canid: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.idAssignmentRequest}
 */
proto.sparkmax.idAssignmentRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.idAssignmentRequest;
  return proto.sparkmax.idAssignmentRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.idAssignmentRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.idAssignmentRequest}
 */
proto.sparkmax.idAssignmentRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.sparkmax.rootCommand;
      reader.readMessage(value,proto.sparkmax.rootCommand.deserializeBinaryFromReader);
      msg.setRoot(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setUniqueid(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setCanid(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.idAssignmentRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.idAssignmentRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.idAssignmentRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.idAssignmentRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRoot();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.sparkmax.rootCommand.serializeBinaryToWriter
    );
  }
  f = message.getUniqueid();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = message.getCanid();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
};


/**
 * optional rootCommand root = 1;
 * @return {?proto.sparkmax.rootCommand}
 */
proto.sparkmax.idAssignmentRequest.prototype.getRoot = function() {
  return /** @type{?proto.sparkmax.rootCommand} */ (
    jspb.Message.getWrapperField(this, proto.sparkmax.rootCommand, 1));
};


/** @param {?proto.sparkmax.rootCommand|undefined} value */
proto.sparkmax.idAssignmentRequest.prototype.setRoot = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.sparkmax.idAssignmentRequest.prototype.clearRoot = function() {
  this.setRoot(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.sparkmax.idAssignmentRequest.prototype.hasRoot = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional uint32 uniqueId = 2;
 * @return {number}
 */
proto.sparkmax.idAssignmentRequest.prototype.getUniqueid = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.sparkmax.idAssignmentRequest.prototype.setUniqueid = function(value) {
  jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional uint32 canId = 3;
 * @return {number}
 */
proto.sparkmax.idAssignmentRequest.prototype.getCanid = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.sparkmax.idAssignmentRequest.prototype.setCanid = function(value) {
  jspb.Message.setProto3IntField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.sparkmax.identifyRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.sparkmax.identifyRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.sparkmax.identifyRequest.displayName = 'proto.sparkmax.identifyRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.sparkmax.identifyRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.sparkmax.identifyRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.sparkmax.identifyRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.identifyRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    uniqueid: jspb.Message.getFieldWithDefault(msg, 1, 0),
    canid: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.sparkmax.identifyRequest}
 */
proto.sparkmax.identifyRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.sparkmax.identifyRequest;
  return proto.sparkmax.identifyRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.sparkmax.identifyRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.sparkmax.identifyRequest}
 */
proto.sparkmax.identifyRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setUniqueid(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setCanid(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.sparkmax.identifyRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.sparkmax.identifyRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.sparkmax.identifyRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.sparkmax.identifyRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getUniqueid();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getCanid();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
};


/**
 * optional uint32 uniqueId = 1;
 * @return {number}
 */
proto.sparkmax.identifyRequest.prototype.getUniqueid = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.sparkmax.identifyRequest.prototype.setUniqueid = function(value) {
  jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional uint32 canId = 2;
 * @return {number}
 */
proto.sparkmax.identifyRequest.prototype.getCanid = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.sparkmax.identifyRequest.prototype.setCanid = function(value) {
  jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * @enum {number}
 */
proto.sparkmax.telemetryId = {
  SENSORPOSITION: 0
};

goog.object.extend(exports, proto.sparkmax);
