syntax = "proto3";

package sparkusb;

/* Interface functions for service sparkusb.
* All command requests are serialized into a
* RequestWire type before transmission, and
* Deserializezd to a ResponseWire on recipt
*/
service sparkusb {
    /*
    * Connect to the requested serial port. If no port
    * is provided, connect to the default port, which is
    * the first port found with a SPARK device.
    */
    rpc Connect(controlRequest) returns (controlResponse) {}

    /*
    * Disconnect the serial port
    */
    rpc Disconnect(controlRequest) returns (controlResponse) {}

    /*
    * Ping the SPARK to verify connection to the hardware and to
    * this server.
    */
    rpc Ping(controlRequest) returns (controlResponse){}

    /*
    * List the serial port information for all connected
    * SPARK devices.
    */
    rpc List(listRequest) returns (listResponse) {}

    /*
    * Update the firmware of the device
    */
    //rpc Firmware(firmwareRequest) returns (firmwareResponse) {}

    /*
    * Send a Heartbeat to the SPARK device (similar to how the roboRIO
    * heartbeat to the device over CAN). This message can be simplified
    * if driving the motor by calling Setpoint({Enable: true})
    */
    rpc Heartbeat(heartbeatRequest) returns (rootResponse) {}

    /*
    * Change the SPARK address. Currently done through SetParameter()
    */
    //rpc Address(addressRequest) returns (addressResponse) {}

    /*
    * Set a device parameter. The parameter should be configParam type
    * the value is a string in both the request and response.
    */
    rpc SetParameter(parameterRequest) returns (parameterResponse) {}

    /*
    * Get a device parameter. The parameter should be configParam type
    * the value returned is a string in both the request and response.
    * The requested value type is also passed to help decode. The type
    * is of type paramType
    */
    rpc GetParameter(parameterRequest) returns (parameterResponse) {}

    /*
    * Make all configuration changes permanent for the next time the
    * device powers on. Note: This writes any values that have changed
    * and can only be called when the device is not enabled. Since this
    * method writes directly to FLASH, avoid calling frequently, as each
    * flash location can be written to a total of 10,000 times in its lifetime.
    * Flash wear leveling is being implemented and should be in the release
    * before kickoff
    */
    rpc BurnFlash(rootCommand) returns (rootResponse) {}

    /*
    * Return a list of all available parameters with their name, number, and type
    */
    //rpc ListParameters(parameterListRequest) returns (parameterListResponse) {}

    /*
    * Send a setpoint command. Right now the value should be from 1023 to -1024
    * however this will change to native units (+/- 1.0 for duty cycle control).
    * Setting Enable = true will also send a heartbeat allowing the controller
    * drive the motor.
    */
    rpc Setpoint(setpointRequest) returns (setpointResponse) {}
}

/*
* Data format to send over 0mq containing one request
*/
message RequestWire {
    oneof req {
        rootCommand             root = 10;
        commandLineRequest      cmdLine = 11;
        listRequest             list = 12;
        firmwareRequest         firmware = 13;
        heartbeatRequest        heartbeat = 14;
        addressRequest          address = 15;
        parameterRequest        parameter = 16;
        parameterListRequest    parameterList = 17;
        setpointRequest         setpoint = 18;
        controlRequest          control = 19;
    }
}

/*
* Data format to recieve over 0mq containting one response
*/
message ResponseWire {
    oneof resp {
        rootResponse            root = 10;
        commandLineResponse     cmdLine = 11;
        listResponse            list = 12;
        firmwareResponse        firmware = 13;
        addressResponse         address = 14;
        parameterResponse       parameter = 15;
        parameterListResponse   parameterlist = 16;
        setpointResponse        setpoint = 17;
        controlResponse         control = 18;
    }
}

/*
* Types of control message to send
*/
enum controlMessage {
    controlPing = 0;
    controlConnect = 1;
    controlDisconnect = 2;
}

/*
* Request format for connect() disconnect() and ping()
*/
message controlRequest {
    controlMessage ctrl = 1;
    string device = 2;
}

/*
* Response format for connect() disconnect() and ping()
*/
message controlResponse {
    bool connected = 1;
}


message commandLineRequest {
    string stdin = 1;
}

message commandLineResponse {
    string stderr = 1;
    string stdout = 2;
}

/*
* All RPC services implement this request
* keepalive and help are not implemented
*/
message rootCommand {
    string device = 1;
    bool keepalive = 2;
    bool help = 3;
}

/*
* All RPC services implement this response
* helpString not implemented
*/
message rootResponse {
    string helpString = 1;
    string error = 2;
}

/*
* Request format for list() command
*/
message listRequest {
    rootCommand root = 1;
    bool all = 2;
}

/*
* Response format for list() command
*/
message listResponse {
    repeated string deviceList = 1;
    repeated string deviceDetails = 2;
    rootResponse root = 3;
}

/*
* Request format for firmware() command
*/
message firmwareRequest {
    rootCommand root = 1;
    string filename = 2;
}

/*
* Response format for list() command
*/
message firmwareResponse {
    string version = 1;
    rootResponse root = 3;
}

/*
* Request format for heartbeat() command
*/
message heartbeatRequest {
    rootCommand root = 1;
    bool enable = 2;
}

/*
* Request format for address() command
*/
message addressRequest {
    rootCommand root = 1;
    uint32 address = 2;
}

/*
* Response format for address() command
*/
message addressResponse {
    uint32 currentAddress = 1;
    uint32 previousAddress = 2;
    rootResponse root = 3;
}

/*
* Parameter ID for set/get parameter fields
* these values match the SPARK firmware
*/
enum configParam {
    CanID = 0;
    InputMode = 1;
    MotorType = 2;
    CommAdv = 3;
    SensorType = 4;
    CtrlType = 5;
    IdleMode = 6;
    InputDeadband = 7;
    FirmwareVersion = 8;
}

/*
* Motor type enum, these values match the SPARK firmware
*/
enum motorType {
    Brushed = 0;
    Brushless = 1;
}

/*
* Sensor type enum, these values match the SPARK firmware
*/
enum sensorType {
    HallSensor = 0;
    Encoder = 1;
    Sensorless = 2;
}

/*
* Control type enum, these values match the SPARK firmware
*/
enum ctrlType {
    DutyCycle = 0;
    Velocity = 1;
}

/*
* Idle mode type enum, these values match the SPARK firmware
*/
enum idleMode {
    Coast = 0;
    Brake = 1;
}

/*
* Faults type enum, these values match the SPARK firmware
*/
enum faults {
    Brownout = 0;
    Overcurrent = 1;
    Overvoltage = 2;
    MotorFault = 3;
    SensorFault = 4;
    Stall = 5;
    EEPROMCRC = 6;
}

/*
* Sticky type enum, these values match the SPARK firmware
*/
enum stickyFaults {
    BrownoutSticky = 0;
    OvercurrentSticky = 1;
    OvervoltageSticky = 2;
    MotorFaultSticky = 3;
    SensorFaultSticky = 4;
    StallSticky = 5;
    EEPROMCRCSticky = 6;
}

/*
* Parameter type enum, these values match the SPARK firmware
* and are sent as a response in GetParameter() requests
*/
enum paramType {
    int32 = 0;
    uint32 = 1;
    float32 = 2;
}

/*
* Request type for Set/Get Parameter()
* value is not set to signify a 'Get' command
*/
message parameterRequest {
    rootCommand root = 1;
    configParam parameter = 2;
    string value = 3;
}

/*
* Response type for Set/Get Parameter()
*/
message parameterResponse {
    string value = 1;
    paramType type = 2;
    rootResponse root = 4;
}

message parameterListRequest {
    rootCommand root = 1;
}

message parameterListResponse {
    repeated string parameter = 1;
    repeated paramType type = 2;
    rootResponse root = 3;
}

/*
* Request format for Setpoint() command
*/
message setpointRequest {
    rootCommand root = 1;
    float setpoint = 2;
    bool enable = 3;
}

/*
* Response format for Setpoint() command
* isRunning is not implemented yet
*/
message setpointResponse {
    float setpoint = 1;
    bool isRunning = 2;
    rootResponse root = 3;
}